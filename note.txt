
chrome 
ctrl-shift-j console chrome
ctrl-shift-i elements
ctrl-shift-m modo mobile on/off
console chrome: posso usarla come calcolatrice !!

vscode
ctrl+ù toggle comments 
IN HTML: ! + TAB  SCRIVE TEMPLATE HTML DI BASE 
sostituire stringhe multiple: selezionare stringa, ctrl+d tante volte quante le stringhe, scrivere..

windows
win+è emoticons

ROBA UTILE DA INSTALLARE IN VSCODE 
	LIVE SERVER
	
PAROLE UTILI PER SPIEGARE
	ELEMENTS HTML, NO TAG, I TAG SONO I DELIMITATORI, UN ELEMENTO INPUT, UN ELEMENTO SELECT ECC..
	STICKY NAVIGATION = LA BARRA DI NAVIGAZIONE CHE COMPARE DOPO UN PO' DI SCROLL DELLA PAGINA 
		IN PRATICA AGGIUNGO UN CLASS STICKY ALL'ELEMENTO HEADER NEL BODY CHE IMPOSTA POSITION: FIXED E BACKGROUND-COLOR TRASPARENTE (255,255,255)
			.nav.sticky {
			  position: fixed;
			  background-color: rgba(255, 255, 255, 0.95);
			}		
		PER IMPLEMENTARE NON USARE window.addEventListener('scroll' ...) PERCHE' POCO EFFICENTE 
		
	TABBED COMPONENT = COMPONENTE CON BOTTONI DISPOSTI A TAB, UNO DOPO L'ALTRO 
	
	
*** APPROFONDIMENTO HTML 
	* quando viene eseguita function associata ad onclick su bottone che sta dentro una form, il comportamento di default è il submit della form e il reload della pagina.
		per evitare: nella callback associata all'evento, oggetto in input event, invocare metodo e.preventDefault();		
	* quando si clicca su un anchor con #, perché lancia function, il default behaviour è lo scroll up to the top page. per evitare aggiungere e.preventDefault() come prima istruzione della function dell'evento. 
	* getElementsByClassName e getElementsByTagName restituiscono HTMLCollection che si aggiorna in automatico al variare del DOM ! querySelectorAll che restituisce NodeList non lo fa !
	* quando si crea un nuovo elemento html lo si può mettere in un solo punto del DOM, per esempio con append, ma non piu' di uno ! se lo faccio, per esempio prima prepend poi append, l'elemento viene spostato ! per copiarlo copiare l'elemento con append(elemento.cloneNode(true)) (se true copia anche i child dell'elemento) 

*** ESEMPI JS FIGHI 
// seleziono tutti elementi con class movements__row e cambio il colore di background in funzione pari/dispari
[...document.querySelectorAll(".movements__row")].forEach((elem, i) => elem.style.backgroundColor = `${i % 2 === 0 ? "green" : "yellow"}`);

// faccio traversing del DOM selezionando tutti i sibling di un h1 (salendo sul padre e poi ottenendo i children) e su questi, converto in array con spread e con foreach applico a tutti, meno che all'h1 un transform 
[...h1.parentElement.children].forEach(function(el){
	el !== h1 && el.style.transform = "scale(0.5)";
});

// event listener con function esterna a cui passo l'oggetto this con i parametri che mi servono, usando bind 
const handleClick = function (e) {		// devo per forza dichiarare solo il parametro e
  console.log(e.target.src, this.param);
}
document.querySelector('.nav__logo').addEventListener('click', handleClick.bind({ param: "giggi" }));

// chiedere conferma dell'uscita dalla pagina, quando l'utente chiude tab o browser 
window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  console.log('window.beforeunload', e);
  e.returnValue = '';		// in chiusura tab o browser fa uscire il popup che chiede conferma, ma non si può personalizzare il messaggio (una volta si poteva ma poi abuso e quindi tolto potere :)) 
})		
	
BEST PRACTICES 
	HTML
		. NON USARE ID PER SELEZIONARE O APPLICARE STYLE A ELEMENTI, USARE INVECE CLASS !!
		. ID E CLASS SI SCRIVONO CON -, NON IN CAMELCASE, ESEMPI: course-image, your-name 
		. innerHTML (per i div) E' una property !!
		. textContent (per i P) e' una property !! ma anche per i div !
		. e.preventDefault() usare in callback click di bottone dentro form per evitare il submit della form e il reload della pagina
		. value (per gli input) è una property !
		. blur() su elemento: perde focus. 		
		. getElementsByClassName e getElementsByTagName restituiscono HTMLCollection che si aggiorna in automatico al variare del DOM ! querySelectorAll che restituisce NodeList non lo fa !
			posso convertire HTMLCollection in array usando spread [...oggetto] oppure Array.from(oggetto) 
		. elemento.getAttribute('attributo-custom') legge gli attributi non standard che ho impostato nel DOM, infatti elemento.attributo-custom non funziona !
			immagine.getAttribute('src') restituisce l'url relativo, mentre immagine.src l'url assoluto !
			IDEM CON href !!
		. elemento.setAttribute('attributo-custom','valore') imposto attributo custom con valore specificato
		. elemento.className restituisce l'attributo class dell'elemento quindi i suoi class 
			NOTA BENE: NON USARE className PER IMPOSTARE CLASSE PERCHE' SOVRASCRIVE TUTTO ! USARE classList.add VEDI SOTTO E OLTRE 
		. elemento.classList restituisce un oggetto con cui posso aggiungere, rimuovere classi, toggle, contains , vedi sotto 
		. elemento.dataset.attributoData per interagire con data attributes, cioè quelli che iniziano con data-. in js usare notazione camelCase senza data-
		
	CSS 
		. elemento.style RESTITUSCE SOLO GLI STYLE INLINE, CIOE' QUELLI CHE HO IMPOSTATO MANUALMENTE CON elemento.style.property=valore 
		. getComputedStyle(elemento) RESTITUISCE TUTTE LE PROPERTY STYLE DELL'ELEMENTO CON I RELATIVI VALORI ! 
			getComputedStyle(elemento).property RESTITUISCE IL VALORE DELLA PROPERTY 
			ATTENZIONE: getComputedStyle(elemento).height torna per esempio '50px' quindi una stringa. se voglio partire da questo per aumentare height devo prima convertire la stringa in un numero usando parseFloat e poi aggiungere il numero e poi la stringa 'px': 
				message.style.height = parseFloat(getComputedStyle(message).height) + 40 + 'px';
		. CSS Custom Properties: sono vere e proprie variabili inizializzate con un valore e riusabili nel CSS. si dichiarano con --nomevariabile: valore;  e si usano con var(variabile) 
			:root {		// root = document element 
			  --color-primary: #5ec576;
			}		
			.section__description {
				color: var(--color-primary);
			}
			Sono modificabili da JS : document.documentElement.style.setProperty(nomevariabile, valore);
				document.documentElement.style.setProperty('--color-primary', 'orangered');
		. style.opacity per schiarire
		. selettore elementi per tag e attributo: img[data-src] 
			document.querySelectorAll(img[data-src])			//seleziono elemento img con attributo data-src
			document.querySelector(`.dots__dot[data-slide="${slide}"]`)		// seleziono elemento con classe dots__dot e attributo data-slide uguale a ... 
		. elemento.style.transform(...) applica trasformazione all'elemento, per esempio
			style.transform = "scale(0.5)"  //rimpicciolisce 
			style.transform = "translateX(-200)" // sposta sull'asse orizzontale, 200 pixel a sinistra
			
				
	JS 
		. usare EVENT DELEGATION per impostare event listener a livello di padre, per esempio un div che contiene dei bottoni e poi nella function fare MATCHING STRATEGY per determinare se sto elaborando l'elemento corretto 
			const tabsContainer = document.querySelector('.operations__tab-container');
			tabsContainer.addEventListener('click', function (e) {
			  const clicked = e.target.closest('.operations__tab');		// uso closest per risalire al bottone più vicino all'elemento che ha provocato il click, può essere il bottone stesso !
			  console.log(clicked.className, clicked.dataset.tab);
			});		
			NOTA BENE: QUANDO SI FA MATCHING STRATEGY E' MOLTO MEGLIO USARE CLOSEST CHE RISALIRE MANUALMENTE PERCHE' E' PIU' ROBUSTO, FUNZIONA ANCHE SE L'HTML VIENE MODIFICATO NEL TEMPO. PER ESEMPIO SE DOVREI RISALIRE DI DUE LIVELLI E POI NE VIENE AGGIUNTO UN TERZO, USANDO CLOSEST ME NE FREGO. 
		. usare le "guard clause" nelle function degli eventi o più in generale: se ho bisogno di un oggetto ma è falsy eseguo return per uscire dalla function !
			invece che mettere il blocco di codice dentro una if in cui testo l'esistenza dell'oggetto
		. usare elemento.querySelector(All)(selettore) per cercare figli, indipendentemente dalla loro profondità nel DOM 
		  usare elemento.closest(selettore) 	       per cercare padri, indipendentemente da quanto stiano più in alto nel DOM. può tornare anche se stesso. 
		. elemento.addEventListener(evento, callback(e){
			e.target //ottengo riferimento all'elemento target event equindi a tutte le sue proprietà
					 // per accedere invece a elemento usare this oppure e.currentTarget
						NOTA BENE: se ho usato bind per impostare l'oggetto this con parametri da passare alla funzione allora this !== e.currentTarget ! però currentTarget rimane inalterato !
			}
		. CONVERTIRE NUMERO IN STRINGA, USARE `${....}`
			`${new Date().getMonth()+1}`
		. CONVERTIRE STRINGA IN NUMERO: 
			Number(stringa)
			+stringa 
			Number.parseFloat(stringa) // tutto quello che non è numero viene ignorato. se non c'è un numero ritorna NaN
			Number.parseInt(stringa) // tutto quello che non è numero viene ignorato. se non c'è un numero ritorna NaN
		. Date.now() TIMESTAMP DI ADESSO 
		. NON USARE VAR, USARE CONST/LET 
		. RANDOM: Math.trunc(Math.random() * 6) + 1  //GENERA NUMERO CASUALE DA 1 A 6 
		. RANDOM: const randomInt = (min, max) => Math.floor(Math.random() * (max - min) + 1) + min;   //FUNZIONE GENERICA PER GENERARE RANDOM TRA DUE NUMERI 
		. PROPERTY/ARGOMENTI NON USATI DICHIARARLI CON _ 
			const arry = Array.from({ length: 7 }, (_, i) => i + 1);		// il primo parametro della callback (elemento corrente) non lo uso per cui lo chiamo _
		. PER TROVARE IN ARRAY SE ESISTE UN OGGETTO USARE INCLUDES(VALORE) (RESTITUISCE TRUE/FALSE) 
			PER VERIFICARE UNA CONDIZIONE DIVERSA DA UGUALE USARE SOME(CALLBACK(CONDITION)) 
		. NON USARE ARROW FUNCTION COME METODI DI UN OGGETTO, IL THIS IN ESSE NON PUNTA ALL'OGGETTO MA AL PRIMO SCOPE PARENT UTILE 
		. USARE ARROW FUNCTION DENTRO UNA FUNCTION IN UN METODO PER POTER USARE IL THIS CHE PUNTA ALL'OGGETTO, ALTRIMENTI DEVO USARE IL TRUCCO DEL SELF/THAT PRIMA DELLA FUNCTION DENTRO IL METODO 
		. USARE STRICT MODE !
		. USARE === !== 
		. NON CONCATENARE METODI DI ARRAY CHE MUTANO L'ARRAY DI PARTENZA, COME SPLICE, REVERSE, ECC. !!!
		. NON ESAGERARE CON CHAIN DI METODI DI ARRAY CON ARRAY DI GRANDI DIMENSIONI: PROBLEMI DI PERFORMANCE !! RIDURRE UTILIZZO DI MAP
		. ATTENZIONE A Object.assign PER FARE COPIA DI OGGETTI: ESEGUE SHALLOW COPY CIOE' COPIA DI PRIMO LIVELLO, PER FARE DEEP CLONE USARE... DA COMPLETARE 
		. USARE CONST CON GLI OGGETTI PER EVITARE (GRAZIE AD ERRORE) CHE VENGANO SOSTITUITI DA ALTRI OGGETTI, ANCHE DA OGGETTO VUOTO
		. GLI ARRAY SONO OGGETTI: ATTENZIONE ! POSSO DEFINIRLI CON CONST E VARIARNE IL CONTENUTO MA NON SOSTITUIRLO CON UN ALTRO ARRAY, PER FARE CIO' DEVO DEFINIRLI CON LET 
		. USARE IL DESTRUCTURING SE HO BISOGNO DI SCAMBIARE IL VALORE DI DUE O PIU' VARIABILI, ANCHE SE NON SONO ARRAY ! 
			let a = "ciao";
			let b = "pippo";
			let [a,b] = [b,a]  // HO SCAMBIATO TRA LORO LE VARIABILI a E b 
		. USARE IL DESTRUCTURING PER RICEVERE PIU' VALORI DA UNA FUNCTION E ASSEGNARLI AD ALTRETTANTE VARIABILI (AL POSTO DI RESTITUIRE UN OGGETTO..)
			NELLA FUNCTION: 
				return [valore1, valore2, ecc..]	// return restituisce array 
			NELL'INVOCAZIONE: 
				const [valore1, valore2, ecc..] = function(..); 	// l'array restituito viene destrutturato in variabili 
		. SI PUO' FARE ANCHE DESTRUCTURING IN UN DESTRUCTURING, SE L'ARRAY IN INPUT HA A SUA VOLTA DEGLI ARRAY 
				const listaNum = [1, 2, [3, 4]];
				const [uno, , [tre, quattro]] = listaNum;
				console.log(uno, tre, quattro);   // SALTO IL DUE E ESTRAGGO TRE E QUATTRO CHE STANNO IN UN ARRAY NELL'ARRAY		
		. USARE DESTRUCTURING DI OGGETTO AL POSTO DI LISTA DI ARGOMENTI IN UNA FUNCTION QUANDO NE HA PARECCHI 
		. USARE SPREAD OPERATOR PER FARE COPIE DI OGGETTI E ANCHE AGGIUNGERE PROPERTY 
			const obj1 = {
			  prop1: 'ciao',
			  prop2: 'da',
			  prop3: 'giggi',
			};
			const obj2 = { ...obj1, prop4: '!!!!' };			
		. USARE REST OPERATOR PER ESTRARRE PROPERTY DA OGGETTO E COPIARE TUTTE LE ALTRE PROPERTI IN UN ALTRO 
			const { G, ...objresto } = testjson;    // estraggo E dall'oggetto testjson e tutti gli altri oggetti li metto in objresto
		. USARE REST OPERATOR IN FUNCTION PER ACCETTARE N ELEMENTI 
			const add = function (...numbers) {		// dichiaro function che riceve N elementi e li impacca nell'array numbers 
			  console.log(numbers);
			}
			add(1, 2, 3, 4, 5);		
			add(1, 2, 3, 4, 5,6, 7,8, 9, 10);
		. USARE OR SHORT CIRCUITING AL POSTO DI TERNARY OPERATOR PER INIZIALIZZARE VARIABILI. MA NON FUNZIONA CON NUMERI ! LO ZERO VIENE VISTO COME FALSY ! USARE INVECE ?? OPERATOR (MA SOLO DA ES2020)
			const ciao = pippo || "ciao"; 	// se pippo è truly torna pippo altrimenti torna "ciao" 
			const ciao2 = pippo ?? "ciao";  // se pippo è truly torna pippo, anche se zero !, altrimenti torna "ciao"
			const forza = undefined || null || '' || 0 || NaN || "forza"; // torna forza 
		. USARE AND SHORT CIRCUITING PER INVOCARE FUNZIONI SOLO SE ESISTONO 
			addProduct && addProduct("product");	//se primo e' truly va avanti e esegue funzione, altrimenti se false si ferma e non esegue niente
		. USARE OPTIONAL CHAINING E NULLISH COALES.. OPERATOR PER COMBINARE TEST DI ESISTENZA (NOT UNDEFINED, NOT NULL) E VALORE DI DEFAULT
			const days = ['mon', 'tue', 'thu', 'wed', 'fri', 'sat', 'sun'];
			console.log('🎉 Orari Apertura 🎉');
			for (const day of days) {
			  const open = restaurant.openingHours[day]?.open ?? 'closed'; // se property day è presente ritorna open altrimenti ritorna "closed" 
			  console.log(`${day} - ${open}`);
			}
		. PER ITERARE SUGLI OGGETTI: 
			. Object.keys(oggetto) RESTITUISCE ITERABLE CON I NOMI DELLE PROPERTY
			. Object.values(oggetto) RESTITUISCE IL VALORE DELLE PROPERTY 
			. Object.entries(oggetto) RESTITUSCE KEY E VALUE IN UN ARRAY DI ARRAY 
			. for (const key in oggetto) {
				console.log(oggetto[key]);
			  }			 
		. PER RIMUOVERE DUPLICATI DA ARRAY USARE new Set(array) E RICONVERTIRE IN ARRAY 
			const arrayConDuplicati = ['aa', 'bb', 'aa', 'bb', 'cc'];
			const arrayUnique = [...new Set(arrayConDuplicati)];    //creo Set dell'array con duplicati e con l'operatore Spread lo espando in un array
		. CONVERTIRE OGGETTO IN MAP CON Object.entries(oggetto)
			const objToMap = new Map(Object.entries(restaurant.openingHours));			
		. RICORDARSI CHE QUANDO DEFINISCO UN OGGETTO POSSO DICHIARARE DELLE PROPERTY UGUALI AD ALTRE NELLO STESSO SCOPE, SEMPLICEMENTE SCRIVENDONE IL NOME E POI VIRGOLA, SENZA QUINDI : ... 
			const createBooking = function (flightNumber, numPassengers, price) {
				const booking = {
					flightNumber,
					numPassengers,
					price,
				}
			}
		. ROBE UTILI SU FUNCTIONS: 
			PROPERTY name NOME FUNCTION PASSATA COME PARAMETRO 
			PROPERTY length NUMERO PARAMETRI FUNCTION 
		. RICORDARSI DEL METODO CALL DELLE FUNCTION E DEL THIS 
			const method = function (nome) {
				console.log(`${this.prop1} ${nome}`);
			}
			const oggetto1 = {
				prop1: "ciao"
			}
			const oggetto2 = {
				prop1: "forza"
			}
			method.call(oggetto1, "oggetto1 !");
			method.call(oggetto2, "oggetto2 !");
		. PER ELIMINARE ULTIMO ELEMENTO DI UN ARRAY: 
			* arr.pop();		
			* arr.splice(-1)  //non slice !! quello lo restituisce e basta 
		. PER OTTENERE ULTIMO ELEMENTO DI UN ARRAY 
			* arr.slice(-1)	//
			* arr.at(-1) 
		. PER COPIARE ARRAY (SOLO PRIMO LIVELLO: SHALLOW COPY): 
			* const arr2 = arr1.slice(); //slice senza parametri copia tutto l'array 
			* const arr2 = [...arr1]; // SPREAD OPERATOR
			* FORSE ANCHE Object.assign
			* const copia = movements.map(e => e); // uso map senza eseguire alcun cambiamento a ciascun elemento 
		. PER CONCATENARE ARRAY: 
			* const arr3 = arr1.concat(arr2);
			* const arr3 = [...arr1, ...arr2]; //SPREAD OPERATOR
		. PER TROVARE UN ELEMENTO IN UN ARRAY 
			* const found = arr.includes(valore); //TORNA TRUE/FALSE 
		. PER TROVARE SE CI SONO UNO O PIU' ELEMENTI CHE SODDISFANO CONDIZIONE 
			* const found = arr.some(el => el condizione); 
		. PER GLI ARRAY: USARE map, filter, reduce !!!
			const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
			// converto euro in dollari usando il metodo map 
			const eurToDollars = movements.map(euro => Math.round(euro * 1.1));				
			// seleziono i soli importi maggiori di zero 
			const deposits = movements.filter(mov => mov > 0);			
			// somma tutti i valori di movements. in reduce accumula la sommatoria in acc, inizializzandolo a zero
			const balance = movements.reduce((acc, mov, i, arr) => acc + mov, 0);		
			
			// combinare i comandi concatenandoli
			// filtro movimenti prendendo solo i deposito, converto ciascuno in dollari, sommo tutto 
			const balanceUSD = movements.filter(mov => mov > 0).map(mov => Math.round(mov * 1.1)).reduce((acc, mov) => acc + mov, 0);
			
			// per fare debug dei singoli comandi usare l'array in input a ciascun comando: 
			const balanceUSD = movements
				.filter(mov => mov > 0)
				.map((mov, i, arr) => {		// aggiungo arr per poter fare console.log, ricordarsi di aggiungere le graffe e return quando c'è più di un'istruzione !!
				  i == 0 && console.log(arr);  // con i == 0 && eseguo console.log solo nel primo item invece che per tutti !
				  return Math.round(mov * 1.1);
				})
				.reduce((acc, mov) => acc + mov, 0);			
		. PER SORTARE ARRAY CON SOLE STRINGHE 
			arr.sort()
		. PER SORTARE ARRAY CON SOLI NUMBER: 
			// Ascending
			movements.sort((a, b) => a - b)
			// Descending
			movements.sort((a, b) => b - a)
		. PER DICHIARARE ARRAY DI N ELEMENTI E INIZIALIZZARLO RIEMPENDOLO CON UN VALORE (E' MUTABLE!): 
			const arr3 = new Array(5)
			arr3.fill("ciao");			
		. PER RIDURRE UN ARRAY AD UN OGGETTO, PER ESEMPIO FACENDO SOMMATORIE USARE reduce()
			const sums = accounts.flatMap(acc => acc.movements).reduce((sums, mov) => {
			  sums[mov > 0 ? "sumDepositi" : "sumPrelievi"] += mov;
			  return sums;
			}, { sumDepositi: 0, sumPrelievi: 0 });		
		. PER ESEGUIRE SCROLL SU UN OGGETTO IN PAGINA 
			  elementotarget.scrollIntoView({
				behavior: "smooth"		//altri valori per animazione: auto, instant
			  })		
		. USARE ATTRIBUTO HREF DI UN ANCHOR, QUELLO CON #..., COME SELETTORE PER FARE QUERYSELECTOR SUL TARGET DELL'ANCHOR, PER ESEMPIO PER ESEGUIRE UNO SCROLL "SMOOTH" AL POSTO DI QUESTO ISTANTANEO DI DEFAULT  
		
		
		
			
		

NOTA BENE: IN GULP IL CHECK DELLA VERSIONE VIENE FATTO DA BABEL, CON FALLBACK PER GESTIRE CODICE IN VECCHI BROWSER. APPROFONDIRE. 

variabili
	caratteri ammessi: _ $
	non possono iniziare con numeri 
	"name" si può ancora usare ma può dare problemi 
	scrivere le costanti tutto in maiuscolo 
	
data types, sono 7 
	number: sono tutti floating, cioè hanno i decimali ! anche quando definisco un "intero" let age = 23 in realtà per js è 23.0
	string
	boolean 
	undefined: valore assunto da una variabile che non è stata ancora defined (empty value). es: let age; ma è anche il tipo di "dato" di una variabile non valorizzata. 
				quindi se dichiaro una variabile senza valore, il suo valore sarà undefined e il suo tipo (typeof) sarà undefined 
				infatti typeof undefined (il valore) restituisce undefined (il tipo) 
				attenzione che typeof restisce il tipo in una stringa ! quindi se faccio typeof typeof undefined ottengo string perché il tipo di dato del risultato di typeof undefined è "undefined" che è una stringa :)
	null: empty value, come undefined.. 
		stranezza: typeof null restituisce "object" ! e' un bug di una vecchia versione di JS mantenuto per legacy
	Symbol (introdotto con ES2015) value unico e che non può essere modificato ? 
	BigInt (introdotto con ES2020) per numeri troppo grandi per number 
	
	NB: è il valore che è di un tipo, non la variabile!. le variabili non devono essere manualmente definite di un tipo, lo fa dinamicamente JS in base al valore immesso nella variabili (Dynamic Typing). 
		da qui deriva la possibilità di valorizzare una variabile con valori di tipo diverso, per esempio prima numero e poi stringa.
		proprio per questo esiste l'operatore typeof che mi dice di che tipo è un valore o una variabile valorizzata
		per esempio typeof true restituisce boolean 
		
	cambiare valore ad una variabile si dice mutating the variable 

commenti 
	vs code: 
	
dichiarare variabili: 
	let usare per variabili che cambieranno valore 
	var è come let, non usare, roba vecchia e poi è scope global
	const dichiarare una costante, il cui valore non può essere mutato (immutable variable); non possono essere dichiarate senza valore, è illegal
		const ageOfBirth = 1991; 
		BEST PRATICE: usare const come prima scelta, e let solo se ho bisogno di cambiare valore in seguito. mutable variables aumentano la probabilità di bug nel codice. 
		NOTA BENE: solo i dati primitivi sono immutable, gli oggetti invece sì ! anche con const !
		
	Posso dichiarare più variabili nella stessa riga di codice: 
		const x, y; 
	Posso assegnare più variabili nella stessa riga: 
		x = y = 20-10;
	
console.log può scrivere n variabili, basta separarle con una virgola, esempio: console.log(variabile1, variabile2, variabile3), vengono separati da uno spazio
	console.log("variabile1: " + variabile1, "variabile2: " + variabile2);
	
operatori matematici 
	+ (anche per concatenare)
	-
	* 
	/ 
	** potenza 2 ** 3 = 2 elevato alla potenza di 3 
	
typeof operator 
assign operator 
	= 
	+= 	variabile = variabile + ...
	*= /=
	++  aggiunge 1 ATTENZIONE: SE ++ SI TROVA A DESTRA INCREMENTA MA RESTITUISCE IL VECCHIO VALORE !! 
							   PER AVERE INCREMENTO REALE METTERE ++ A SINISTRA !
		
	-- toglie 1 
comparison operator 
	< > <= >=  attenzione all'ultima, non scrivere => perché è lambda !
	
operator precedence 
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence
		tabella precedence numbers !
		
Template literals multiline strings 
	Introdotto in ES6 2015 
	usa ` (alt 96) per dichiarare inizio fine template e all'interno ${variabile o espressione} per inserire variabile o un'espressione js come operazione matematica o altro ancora 	
	const log = `var1: ${var1}, var2: ${var2}`
	***** NOTA BENE: il carattere backtick ` si può usare anche delimitatore di stringa, ha il vantaggio di poter usare al suo interno apice singolo o doppio senza problemi WOW !
	inoltre si può andare a capo senza usare backslash e altra roba simile: 
		console.log(`Ciao 
		da
		giggi`);
	
Type Conversion = Manual convertion 
	Number(string) converte stringa in number, se in input c'è qualcosa di diverso da numero restituisce NaN (Not a Number) (typeof NaN restituisce "number" !)
	String(numero) converte number in string 
Type Coercion   = Automatic convertion per esempio quando concateno con l'operatore + stringa con numero, JS converte number in string in automatico.
				 Attenzione: gli operatori matematici -,*,/ fanno il contrario, convertono stringhe in numeri. esempio '23' - '10' risultato 13. 
				 
Truthy e Falsy values: E' IL CONCETTO CHE FA FUNZIONARE L'IF(VARIABILE) !!
	falsy = sono valori che non sono esattamente falsi ma lo diventano quando li converto in boolean. Sono 5: 0, '', undefined, null, NaN 
		Esempio: Boolean(0) restituisce false
	truthy = sono tutti gli altri valori, cioè tutti i numeri non zero e le stringhe non vuote e gli oggetti anche vuoti ({})
		Boolean({}) true (empty object) 
	NOTA: non serve convertire con Boolean perché JS applica Coercion e lo fa implicitamente. 

Nota bene: Da ES2020 ci sono anche i Nullish Value: solo null e undefined, usati con l'operator ?? 
	
Equality Operators 
	=== strict equality operator, confronta senza fare prima type coercion cioè senza fare auto conversion 	USARE QUESTO !!!! EVITA BUG 
		!== diverso da 
	==  loose equality operator, esegue auto convertion prima di fare confronto 
		!= diverso da 
		18 === 18 true 
		18 === '18' false 
		18 == '18' true  (converte prima la stringa in numero e poi confronta) 
	
Prompt 
	input utente, restituisce stringa 
	Esempio: const numero = prompt("inserisci numero"); 
	
if 
	if (..) {
	} else if {
	} else {
	}

Logic operators 
	&& and 
	|| or
	! not 
	
switch..case..default statement 
	switch (variabile) {
		case 'stringa': 
			...
			break;
		case 'stringa': 
			...
			break;
		case 'aaa':
		case 'bbb':
			... (codice sia per aaa che per bbb)
			break;
		default:
			...
	}

Conditional Operator (Ternary, perchè ha tre parti!), è un operator quindi restituisce un valore   
	condizione ? statement per true : (obbligatorio)statement per false;
	const variabile = condizione ? statement per true : (obbligatorio)statement per false;
	si può usare in un Template literals dentro ${...} perchè restituisce valore, a differenza dell'if-then che è uno statement, non restituisce valore e quindi non si può usare dentro  ${...}
	
espressione = restituisce valore 
statement = istruzione

***** FOUNDAMENTALS PART 2 

'use strict';
	prima istruzione di un file js, altrimenti non strict mode non viene attivato
	ci impedisce di fare determinate cose
	crea errori visibili in console quando invece js non in strict mode va in errore in modo silente senza scrivere nulla in console 
		esempi: 
			- quando uso variabile non dichiarata perché ho scritto un typo 
			- quando uso parole chiavi riservate, di uso futuro. tipo interface, private 

** Functions	
	function declaration: usare key word "function" per dichiarare funzione, è possibile invocare la function prima del suo declaration 
		paramentro: dichiarazione della variabile in input nella function 
		argomento : valore passato alla function quando la si invoca, finisce nel parametro 
		formato: 
			function nome(parametri) {
				...
			}
	function expression: dichiaro variabile che valorizzo con una function, non è possibile invocare la function prima della dichiarazione della variabile che la "contiene" 
			const variabile = function (parametri) {  // variabile diventa il nome della function 
				...
			}
			consto var = variable(parametri); 
			NOTA BENE questo formato è possibile perchè la function diventa un'espressione, che può anche restituire un valore 
				Da qui il concetto IMPORTANTE che una function è un value, un valore ! sarà del tipo del dato restituito dal return oppure undefined se la function non restituisce niente 
				
	(ES6) arrow function, una forma abbreviata di function expression, return è implicito se ho un'unica istruzione, altrimenti lo devo scrivere 
			const variable = (parametri) => { // se c'è un unico parametro posso omettere parentesi tonde, se c'è un'unica istruzione posso omettere parentesi graffe e "return" 
				istruzione;
				return ..;
			}
			
** Data structures 
	Arrays (zero-based)
		usare parentesi quadre ('literal syntax')
			const friends = ['Mario', 'Giggi', 'Luca'];
			const friends = ['Mario', 123, 'Luca'];
		usare new Array 
			const anni = new Array(1990, 1995, 2000, 2005, 2023, 'pippo');		// notare che l'array non è tipizzato, può contenere valori di tipo diverso 
			
		accedere: usare sempre parentesi quadre e indice che parte da zero; tra le parentesi posso usare un'espressione che restituisce l'indice voluto
			const amico = friends[0]; // ritorna 'Mario'
			const ultimo = friends[friends.length -1] // ottengo l'ultimo elemento: numero elementi - 1 
			
		n.ro elementi: length 
			
		modificare elemento: 
			friends[2] = 'Pippo';
			NOTA BENE: posso mutare singolo elementi dell'array anche se ho dichiarato l'array con const. Questo perchè solo i tipi di dato primitivi sono immutable mentre gli oggetti, tra i qualli anche Array, sono mutable, anche se dichiarati con const
					   non posso invece sostituire l'array con un altro array ! se lo faccio ricevo errore di oggetto immutable
		
		array dentro array: SI-PUO'-FAREE ! 
			const gianni = ['Gianni', 'Rossi', 2023-1974, [10,20,30]];
			
		array di funzioni: SI-PUO' FARE ! 
			const anni = [calcAge(years[0]), calcAge(years[1]), calcAge(years[years.length-1])];
			
		array operations (methods) 
			push 		aggiunge elementi alla fine dell'array, restituisce nuova lunghezza array
			unshift		aggiunge elementi all'inizio dell'array, restituisce nuova lunghezza array
			pop			elimina l'ultimo elemento dell'array, restituisce l'elemento rimosso
			shift		elimina il primo elemento dell'array, restituisce l'elemento rimosso
			indexOf		restituisce posizione dell'elemento in input, se l'elemento non esiste restituisce -1
			includes(ES6) restituisce true se l'elemento in input esiste nell'array, false se non esiste (testa con strict equality, vuol dire che se l'array ha un number e passo in input la stringa del number, includes non lo trova) 
			concat      concatena l'array con quello/i passato in input 
			sort ! VEDI SOTTO 
		
	Objects
		const oggetto = {
			property: valore,
			property: valore, 
			... 
			property: valore
		};
		valore puo' essere un primitivo, un'espressione, una function, un array, un altro oggetto, ecc.. 
		due modi per riferirsci alle property: 
			oggetto.property	// dot notation
			oggetto["property"] // bracket notation: posso comporre la stringa come voglio, con una variabile, una function ecc.. 
		aggiungere properties: 	// non serve dichiararle in anticipo nell'oggetto, come in java. si possono aggiungere dopo, quando l'oggetto è stato inizializzato
			oggetto.property = valore
			oggetto["property"] = valore 
		definire methods: 
			const oggetto = {
				property: valore, 
				...
				metodo: function(){
					return..
				},
				metodo2: (a,b) => a+b,
				metodo3: () => console.log(this.property) 	// nei metodi, con this posso riferirmi all'oggetto da cui ho invocato il metodo e accedere alle sue properties. 
															   ATTENZIONE CHE NELLE ARROW FUNCTIONS this SI COMPORTA IN MODO DIVERSO !!!!
			}
			
			oggetto.metodo2('aaa','bbb');
			oggetto['metodo2']('ccc','ddd');	//chiamo metodo anche con notazione bracket 
			
** Loops
	for(let indice=1; indice <= 10; indice++){		// finchè la condizione è vera il codice del for viene eseguito in loop
		istruzioni..
		if(...) continue;  // se vero continue salta al loop successivo
	}
	
	while(condizione){
	
	}
	
			
	let indice = ..;
	while(condizione) {			//continua a ripetere fintanto che la condizione è vera
		istruzioni
		istruzioni
		incremento indice
	}
		
	
** METODO DI APPROCCIO ALLA RISOLUZIONE DEI PROBLEMI 
	1. Understand the problem.
		questions..
	2. Breaking-up into sub problems 
	
	METODI CONSOLE 
		console.log
		console.warn
		console.error;
		console.table (ottimo per oggetti) 
		debugger
		console.dir(function) info su function 
		
** HTML CSS ROBA CHE NON SO 
	HTML 
		in input attributo placeholder 
	CSS
		SELECTOR selettore, quelli più semplici sono quelli per cui si scrive il tag per selezionare il rispettivo elemento, per esempio body {...} h1{..}
		PER IMPORTARE: <link href="style.css" rel="stylesheet"/>
		SELECTOR PER CLASS INIZIA CON PUNTO 
		SELECTOR PER ID INIZIA CON #
		
	** BOX MODEL 
		OGNI ELEMENTO IN PAGINA PUO ESSERE INTESO COME UN BOX, UN RETTANGOLO, CON LE SEGUENTI PROPRIETA': 
			- CONTENT 
			- WIDTH: LARGHEZZA
			- HEIGHT: ALTEZZA
			- PADDING: AREA TRASPARENTE ATTORNO AL CONTENT, INSIDE THE BOX. USABILE PER CREARE SPAZIO ALL'INTERNO DEL BOX. PROPERTY padding
			- BORDER: ATTORNO AL PADDING E AL CONTENT 
			- MARGIN: AREA AL DI FUORI DEL BOX, DI FATTO TRA I BOX DI CIASCUN ELEMENTO: SPAZIO TRA I BOX 
			- FILL AREA: AREA CHE VIENE RIEMPITA DA BACKGROUND COLOR E BACKGROUND IMAGE, COMPRENDE CONTENT+PADDING+BORDER MA NON MARGIN !
			

	** ROBA UTILE DA INSTALLARE IN VS CODE 
		PRETTIER 
			poi andare in setting, cercare default formatter, selezionare esbenp.prettier-vscode
				selezionare anche format on save, mettere la spunta su Editor: Format On Save
		SNIPPET, PER EVITARE DI SCRIVERE console.log O ALTRA ROBA RIPETITIVA 
			setting, use snippet, use new global snippet file, dare nome del cavolo, uncomment l'esempio print to console 
			
		LIVE SERVER : PER AUTOMATIZZARE RELOAD BROWSER DOPO MODIFICA A JS 
			aggiunge pulsante GoLive in basso a destra
			per lanciarlo: aprire terminale e nel folder del progetto digitare live-server
			
	** codewars.com challenges for free 
	
	********* CSS **********
	
	inline elements: occupano spazio in una riga, non box, tipo tag anchor, input, button
	block elements : il loro spazio un box che occupa tutta la larghezza dello schermo
	
	commenti: /* .... */
	
	Global Reset: reimpostare tutti i margin e i padding 
		Per selezionare tutti gli elementi usare il selettore * 
	
	* {
		margin: 0;		// quando si imposta zero non serve specificare px o %
		padding: 0;
		box-sizing: border-box; //serve per dichiarare che voglio le dimensioni di un elemento esattamente come le ho dichiarate: se dichiaro una form con width 400 e padding 25 e margin 5, il width non sarà 400+25+25+5 ma la somma di tutto dovrà fare 400 
	}
	
	elemento1, elemento2 {  //stile per più elementi
		...
		...
	}
	
	** child selector: per selezionare un elemento contenuto in un altro elemento scrivo l'elemento che contiene e poi l'elemento contenuto separati da spazio 
	#mio-div h2 {		// seleziono elemento h2 contenuto nell'elemento con id mio-div
	
	}
	
	********** JAVASCRIPT DOM MANIPULATION ***********
	
	document.querySelector('selettore') // esempio .classe #div ecc..
		NOTA se selettore seleziona più elementi, restituisce solo il primo. per avere l'array di tutti gli elementi usare querySelectorAll
		non seleziona come jquery, seleziona proprio l'html dell'elemento selezionato 
		.textContent 	restituisce testo dell'elemento selezionato, per esempio per gli elementi p o anchor 
		.value			restituisce valore di un elemento, per esempio input text 
	
	document.querySelectorAll('selettore') // esempio .classe #div ecc..  seleziona TUTTI gli elementi selezionati dal selettore in input 
		
	DOM = Document Object Manipulation, il browser crea una rappresentazione ad albero di tutti gli elementi dell'html 
		essendo un albero sono validi tutti i concetti tipici: child element, parent element, sibling element (fratello) ecc.. 
		per esempio un elemento P contenente un testo e un anchor, sarà un elemento con due child: text e a, il primo valorizzato col testo, il secondo con un child text per il suo testo 
		document è l'oggetto entry point del DOM 
		DOM non fa parte di Javascript ma fa parte del WEB APIs, implementate in ciascun browser e con le quali Javascript si interfaccia 
		
	Event Listener = codice eseguito al verificarsi di un evento ad uno specifico elemento 
		selezionare elemento, per esempio un button, e poi addEventListener 
		document.querySelector('.check').addEventListener(evento, funzione);
		
		document.querySelector('body').style.backgroundColor = '#60b347' 		// seleziono body element e imposto css style background-color che in javascript si scrive in Camel Case quindi backgroundColor  
																				// gli style si impostano sempre con una stringa ! no numeri
																				
		document.getElementById('id')	// get per id, non serve cancelletto !
																				
	elementoselezionato.classList	// restituisce elenco di classi dell'elemento 
		classList.remove('hidden','','') // rimuovo uno o più classi dall'elemento, non mettere il punto davanti !
		classList.add 
		classList.contains('hidden')     // 
		classList.toggle('class')   	 // se c'è il class lo toglie, altrimenti lo aggiunge 
		
	elementoselezionato.src = url 	// imposto l'attributo src a un elemento che lo supporta come img 
		
	Global events: sono quelli della tastiera, legati al document, quindi l'addEventListener in questo caso lo si fa su document 
		tre eventi intercettabili: 
			keyup		
			keypress
			keydown
		document.addEventListener('keydown', function(e){
			// nell'oggetto e che riceviamo in input ci sono tutte le info sull'evento catturato
			
		});
		
		
		
	*********** COME FUNZIONA JAVASCRIPT  ***************
	
	* MULTI-PARADIGM: 
		. PROCEDURAL PROGRAMMING 
		. OBJECT-ORIENTED PROGRAMMING
		. FUNCTIONAL PROGRAMMING
	  E: 
		. IMPERATIVE 
		. DECLARATIVE 
	
	* PROTOTYPE: E' LA CLASSE !! CREO IL PROTOTYPE CON TUTTI I METODI E POI QUANDO LO USO, L'OGGETTO CREATO EREDITA TUTTI I METODI 
	
	* FIRST-CLASS FUNCTIONS: QUANDO LE FUNCTIONS SONO GESTITE COME VARIABILI, POSSO PASSARE UNA FUNCTION COME PARAMETRO AD UN'ALTRA FUNCTION E UNA FUNCTION PUO' RESTITUIRE COME RISULTATO UNA FUNCTION 
	
	* DYNAMIC: LE VARIABILI NON SONO TIPIZZATE, LO SONO I VALORI ASSEGNATI ALLE VARIABILI. QUANDO ASSEGNO VALORI DIVERSI AD UNA VARIABILE, IL DATA TYPE DELLA VARIABILE VIENE CAMBIATO AUTOMATICAMENTE
		ESISTE TYPESCRIPT: UNA VERSIONE DI JAVASCRIPT CON VARIABILI TIPIZZATE, COME JAVA. 
		
	* JAVASCRIPT E' SINGLE THREAD: PUO' FARE SOLO UNA COSA ALLA VOLTA ! 
		COSA SUCCEDE PERO SE UN OPERAZIONE DURA MOLTO, PER ESEMPIO FETCH DI DATI DAL SERVER ? HO BISOGNO DI UN NON-BLOCKING BEHAVIOUR, LO SI OTTIENE COL EVENT LOOP: CIOE' FAR GIRARE LONG RUNNING TASK IN "BACKGROUND" E POI RIMETTERLI NEL MAIN THREAD QUANDO SONO TERMINATI, NON HO CAPITO !
		
	* JAVASCRIPT ENGINE 	E' UN PROGRAMMA CHE ESEGUE CODICE JAVASCRIPT, ESEMPIO: V8 DI GOOGLE CHROME, USATO ANCHE IN NODE.JS 
		E' COMPOSTO DA: 
		. CALL STACK 	E' DOVE VIENE ESEGUITO IL CODICE, USANDO L'EXECUTION CONTEXT, IN PARTICOLARE ESISTE UN SOLO "GLOBAL" EC, PER L'ESECUZIONE DEL TOP-LEVEL CODE, E TANTI EC QUANTI SONO LE FUNCTION E I METODI PRESENTI
			JAVASCRIPT ERA UN LINGUAGGIO INTERPRETATO MA ORA USA SIA COMPILAZIONE CHE INTERPRETE, E' JUST-IN-TIME (JIT) COMPILATION: L'INTERO CODICE VIENE COMPILATO IN CODICE MACCHINA E POI ESEGUITO IMMEDIATAMENTE, NON VIENE PRODOTTO UN FILE COMPILATO, IL CODICE COMPILATO VIENE ESEGUITO IMMEDIATAMENTE 
		. HEAP 			E' UN POOL DI MEMORIA NON STRUTTURATO CHE MEMORIZZA TUTTI GLI OGGETTI DI CUI HA BISOGNO DI CODICE IN ESECUZIONE 
			
	* JAVASCRIPT RUNTIME DEL BROWSER, E' COMPOSTO DA: 
		. JAVASCRIPT ENGINE 
		. WEB APIs (DOM, TIMERS, Fetch API, altro..) 
		. CALLBACK QUEUE (click, timer, data..): E' UNA STRUTTURA DATI CHE ACCOGLIE LE FUNCTION DI CALLBACK NEL MOMENTO IN CUI VENGONO EVOCATE
			UNA FUNZIONE DI CALLBACK ("RICHIAMO") E' UNA FUNCTION CHE VIENE INVOCATA PER ESEMPIO AL VERIFICARSI DI UN EVENTO.
			QUANDO L'EVENTO SI VERIFICA, PER ESEMPIO IL CLICK SU UN BUTTON, VIENE CHIAMATA LA RELATIVA FUNCTION DI CALLBACK, DICHIARATA IN button.addEventListener('click', function).
			QUESTA FUNCTION VIENE AGGIUNTA IN CODA ALLA CALLBACK QUEUE E QUANDO IL CALL STACK DELL'JS ENGINE E' VUOTO (NON STA ESEGUENDO NULLA) ALLORA LA FUNCTION VIENE PASSATA DALLA QUEUE AL CALL STACK E LI' VIENE ESEGUITA. 
		. EVENT LOOP 
			IL PROCESSO CHE SI OCCUPA DI PASSARE LE FUNCTION DALLA QUEUE ALLO CALL STACK QUANDO E' VUOTO SI CHIAMA *EVENT LOOP* 
			E' ESSENZIONALE PER IL NON-BLOCKING CONCURRENT MODEL 
			
	* JAVASCRIPT RUNTIME IN NODE.JS: 
		. JS ENGINE 
		. NON CI SONO LE WEB APIs, ESISTONO SOLO NEI BROWSER, MA ESISTONO C++ BINDINGS E THREAD POOL 
		. CALLBACK QUEUE 
		. EVENT LOOP 
					
	IN ESECUZIONE, DOPO CHE IL CODICE E' STATO APPENA COMPILATO, VIENE CREATO IL *GLOBAL EXECUTION CONTEXT* PER IL "TOP-LEVEL CODE" CIOE' IL CODICE JS CHE STA AL DI FUORI DELLE FUNCTION, E IN QUESTO CONTEXT VIENE ESEGUITO APPUNTO IL TOP-LEVEL CODE. IN UN JAVASCRIPT ENGINE ESISTE SOLO UN GLOBAL EXECUTION CONTEXT, E N ALTRI EXECUTION CONTEXT, UNA PER OGNI FUNCTION 
	UN *EXECUTION CONTEXT* E' UN ENVIRONMENT IN CUI VIENE ESEGUITO DEL CODICE JS, MEMORIZZA TUTTE LE INFO NECESSARIE PER LA SUA ESECUZIONE, COME VARIABILI, ARGOMENTI PASSATI ALLE FUNZIONI ECC..
		QUINDI IL CODICE JS VIENE ESEGUITO SEMPRE DENTRO UN EXECUTION CONTEXT. 
		VIENE CREATO UN SOLO GLOBAL EC, PER IL TOP-LEVEL CODE, E UN EC PER OGNI FUNCTION E METODO ESEGUITI, CON TUTTO QUELLO CHE SERVE PER LA LORO ESECUZIONE. L'INSIEME DI TUTTI GLI EC FORMA IL *CALL STACK*. 
		QUANDO TUTTO IL CODICE E' STATO ESEGUITO, L'ENGINE DI JS ATTENDERA' L'INVOCAZIONE DELLE FUNZIONI DI CALLBACK, PER ESEMPIO QUELLE ASSOCIATE AGLI EVENTI, CHE GLI VERRANNO FORNITE DAL EVENT LOOP, CHE LE ANDRA' A PRENDERE DAL CALLBACK QUEUE. 
		
	COSA C'E' DENTRO UN EXECUTION CONTEXT (RICORDIAMO NE ESISTE UNO PER OGNI FUNCTION ESEGUITA NEL CALL STACK): 
		. VARIABLE ENVIRONMENT: DICHIARAZIONI DI VAR, LET, CONST, FUNCTION, arguments OBJECT CHE CONTIENE GLI ARGOMENTI PASSATI ALLA FUNCTION 
		. SCOPE CHAIN: RIFERIMENTI ALLE VARIABILI AL DI FUORI DELLA FUNCTION 
		. OGGETTO this ! 
	TUTTO QUESTO VIENE CREATO IN UNA FASE APPENA PRIMA L'ESECUZIONE, CHE SI CHIAMA "CREATION PHASE". 
	*** NOTA BENE SUGLI ARROW FUNCTIONS: GLI EC DELLE ARROW FUNCTION NON HANNO I LORO SPECIFICI OGGETTI arguments E this MA USANO QUELLI DELLA LORO PIU' VICINA REGULAR FUNCTION PARENT, CIOE' LA FUNZIONE NORMALE (NON ARROW) DI LIVELLO SUPERIORE. (DA APPROFONDIRE)
	
	SCOPING: COME LE VARIABILI SONO ORGANIZZATE E ACCEDUTE. 
		JAVASCRIPT HA IL *LEXICAL SCOPING": LO SCOPING E' CONTROLLATO DALL'USO DI FUNZIONI E BLOCCHI DI CODICE ({...})
	SCOPE: SPAZIO O ENVIRONMENT IN CUI UNA CERTA VARIABILE E' DICHIARATA (VARIABLE ENVIRONMENT DEL CE IN CASO DI FUNCTION). 
		. GLOBAL SCOPE: PER VARIABILI DICHIARATE NEL TOP-LEVEL CODE, QUELLO AL DI FUORI DI TUTTE LE FUNCTIONS E METODI 
			LE VARIABILI DICHIARATE IN GLOBAL SCOPE SONO ACCESSIBILI *OVUNQUE*, INFATTI SI CHIAMANO *GLOBAL VARIABLES*
		. FUNCTION SCOPE: PER VARIABILI DICHIARATE ALL'INTERNO DI UNA FUNCTION, SONO ACCESSIBILI SONO ALL'INTERNO DELLA FUNCTION, NON AL DI FUORI. CHIAMATO ANCHE *LOCAL SCOPE*
		. BLOCK SCOPE (ES6): VARIABILI DICHIARATE CON let O const ALL'INTERNO DEL BLOCCO {  } SONO ACCESSIBILI SOLO DAL CODICE ALL'INTERNO DEL BLOCCO {  }. var INVECE E' ACCESSIBILE ANCHE DALL'ESTERNO DEL BLOCCO, IN PRATICA E' FUNCTION SCOPE ! ANCHE LE FUNCTION DICHIARATE IN UN BLOCCO CON CONST O LET SONO SCOPE BLOCK 
	SCOPE DI UNA VARIABLE: IL PEZZO DI CODICE IN CUI LA VARIABILE PUO' ESSERE ACCEDUTA (O DICHIARATA ?? NON E' CHIARO)
		ATTENZIONE: PER "VARIABILE" SI INTENDE ANCHE LE FUNCTION, CHE IN JAVASCRIPT SONO VALORI MEMORIZZATI IN VARIABILI !
	UNO SCOPE HA ACCESSO ALLE VARIABILI DEGLI SCOPE PIU' ESTERNI: IL MECCANISMO DI RICERCA PER CUI DA UNO SCOPE RISALGO AGLI SCOPE PARENT ALLA RICERCA DELLA DICHIARAZIONE DI UNA VARIABILE SI CHIAMA * VARIABLE LOOKUP IN SCOPE CHAIN*. IL LOOK "DOWN" OVVIAMENTE NON FUNZIONA. 
	** NOTA BENE
		1. SE DICHIARE CON CONST/LET UNA VARIABILE CHE E' GIA' STATA DICHIARATA IN UNO SCOPE PARENT, SI PUO' FARE, NESSUN ERRORE DI RUNTIME ! SONO VARIABILI IN SCOPE DIVERSI E ANCHE PROBABILMENTE IN EXECUTION CONTEXT DIVERSI. 
			VUOL DIRE CHE COL SCOPE CHAIN LA VARIABILE VIENE TROVATA PRIMA. 
			STESSA COSA PER GLI ARGOMENTI DELLE FUNCTION: POSSONO AVERE GLI STESSI NOMI IN PIU' FUNZIONI, NO PROBLEMA. 
		2. DI FATTO L'UNICA DIFFERENZA, CREDO, TRA USARE VAR O CONST/LET E' NEI BLOCCHI DI CODICE. NELLE FUNCTION E NEL TOP-LEVEL CODE NON C'E' NESSUNA DIFFERENZA: LO SCOPE CHAIN E' SEMPRE IN SALITA, MAI IN DISCESA. 
	
	HOISING: MECCANISMO NELL'EXECUTION CONTEXT/VARIABLE ENVIRONMENT PER CUI ALCUNI TIPI DI VARIABILI SONO ACCESSIBILI/USABILI NEL CODICE *PRIMA* CHE VENGANO DICHIARATE. 
		QUESTO SUCCEDE PERCHE' PRIMA DELL'ESECUZIONE DEL CODICE (DOPO CHE E' STATO COMPILATO!), NELLA FASE CHIAMATA *CREATION PHASE*, NEL CODICE VENGONO CERCATE TUTTE LE DICHIARAZIONI DI VARIABILI (COMPRESE LE FUNCTION OF COURSE), E PER OGNI VARIABILE VIENE CREATA UNA PROPERTY NEL *VARIABLE ENVIRONMENT OBJECT*, QUINDI DI FATTO L'ENGINE JS "CONOSCE" OGNI VARIABILE GIA' PRIMA DELL'ESECUZIONE DEL CODICE ! 
		L'HOISTING VARIA A SECONDA DEL TIPO DI VARIABILE: 
									HOISTED 		INITIAL VALUE 			SCOPE								NOTE 
		. FUNCTION DECLARATION 		YES				ACTUAL FUNCTION			BLOCK (solo con strict mode on)		VUOL DIRE CHE POSSO INVOCARE UNA FUNCTION PRIMA DELLA SUA DICHIARAZIONE 
		. VAR VARIABLES*			YES				undefined				FUNCTION							COMPORTAMENTO "WEIRD", MOTIVO PER CUI USARE LET/CONST INVECE CHE VAR
		. LET/CONST					NO				uninitialized, TDZ		BLOCK 								IN REALTA' SONO HOISTATE MA E' COME SE NON LO FOSSERO PERCHE' NON VENGONO INIZIALIZZATE
																												ERRORE ReferenceError: Cannot access 'provalet' before initialization
																												TDZ: TEMPORAL DEAD ZONE, CODICE TRA L'INIZIO DELLO SCOPE E LA DICHIARAZIONE DELLA VARIABILE
																												    E' STATO INTRODOTTO DA ES6 PER EVIDENZIARE USO DI VARIABILI PRIMA DELLA LORO DICHIARAZIONE, INFATTI CON VAR NON OTTENGO ERRORI MA LA VARIABILE E' UNDEFINED !
		. FUNCTION EXPRESSION E 	DIPENDE SE USO LET/CONST O VAR, STESSO COMPORTAMENTO VEDI SOPRA 			IN GENERALE NON SI POSSONO USARE PRIMA DELLA LORO DICHIARAZIONE
		  ARROW FUNCTION 	
		  
		* CONSIDERAZIONI E BEST PRACTICES: 
			. NON USARE VAR ! 
			. DICHIARARE LE VARIABILI ALL'INIZIO DELLO SCOPE 
			. DICHIARARE PRIMA, USARE POI, ANCHE LE FUNCTION ! ANCHE QUELLE DICHIARATE CON "function"
			. NOTA BENE: VAR CREA LA VARIABILE NELL'OGGETTO WINDOWS. LET E CONST NON LO FANNO !! 
			
	**** THIS OBJECT ****
		. VARIABILE SPECIALE CREATA PER OGNI EXECUTION CONTEXT (OGNI FUNCTION).
		. PRENDE IL VALORE DELL (PUNTA ALL..) OWNER DELLA FUNCTION IN CUI IL THIS VIENE USATO
			NOTA BENE: OWNER E' L'OGGETTO CHE INVOCA LA FUNCTION !
		. NON E' STATICA. DIPENDE DA COME LA FUNCTION VIENE INVOCATA E IL SUO VALORE E' ASSEGNATO SOLO QUANDO CIO' AVVIENE: 
			TOP-LINE CODE (SCOPE GLOBAL) THIS PUNTA ALL'OGGETTO WINDOW (CHE E' IL SUO ONWER)
			METHOD					THIS PUNTA ALL'OGGETTO DEL METHOD (CHE E' IL SUO OWNER) 
			SEMPLICE INVOCAZIONE 	IN STRICT MODE: THIS = UNDEFINED	(PERCHE' NON PUNTA A UN OWNER) 
									NON IN STRICT MODE: THIS PUNTA ALL'OGGETTO WINDOW
			ARROW FUNCTION 			NON HA IL "SUO" THIS MA THIS PUNTA AL PRIMO FUNCTION NORMALE (NON ARROW) CHE CONTIENE L'ARROW FUNCTION (SI DICE "LEXICAL THIS") 
			EVENT LISTENER			THIS PUNTA ALL'ELEMENTO DOM A CUI LA FUNCTION E' COLLEGATA (CHE E' IL SUO OWNER) 
			new, call, apply, bind  PIU' AVANTI NEL CORSO.. 
			
		. THIS NON PUNTA *MAI* ALLA FUNCTION IN CUI VIENE USATA, SE PUNTA, PUNTA A QUALCOS'ALTRO. INOLTRE NON PUNTA *MAI* ALLA VARIABLE ENVIRONMENT DELLA FUNCTION IN CUI VIENE USATA 
		. ATTENZIONE AGLI OGGETTI: LE PARENTESI { } PER DEFINIRLO NON SONO UN BLOCK, NON HANNO BLOCK SCOPE ! PER CUI UN OGGETTO DICHIARATO IN TOP-LINE CODE HA GLOBAL SCOPE. 
		. NON USARE ARROW FUNCTION COME METODI DI UN OGGETTO !
		. SE HO BISOGNO DI DICHIARARE UNA FUNCTION DENTRO UN METODO E VOGLIO CHE IL THIS PUNTI ALL'OGGETTO HO DUE SOLUZIONI: 
			. (PRE ES6): PRIMA DELLA FUNCTION DICHIARO UNA VARIABILE VALORIZZATA CON THIS, DI SOLITO CHIAMATA CON THAT O SELF 
				const that = this; 
				function ... 	
					that.property 
			. (ES6): DICHIARO LA FUNCTION CON UN'ARROW FUNCTION INVECE CHE COME FUNZIONE REGOLARE, IN QUESTO MODO IL THIS NELL'ARROW FUNCTION PUNTA AL PRIMO SCOPE PARENT E QUINDI AL METODO, CHE PUNTA ALL'OGGETTO 
			
	**** ARGUMENTS OBJECT ****
		. E' UN ARRAY CON L'ELENCO DI TUTTI I PARAMETRI PASSATI ALLA FUNCTION, ANCHE QUELLI PER CUI NON HO PREVISTO UN NOME NELL'ELENCO (...) 
		. NOTA BENE: ARROW FUNCTION NON HANNO QUESTO OGGETTO, COME IL THIS 
		
	**** PRIMITIVI VS OGGETTI, BY VALUE, BY REFERENCE 
		. I TIPI PRIMITIVI (String, number, null, undefined, BigInt, Boolean, Symbol) SONO MEMORIZZATI NEL CALL STACK !, NELL'EXECUTION CONTEXT IN CUI SONO STATI DICHIARATI
			PER OGNI VARIABILE VIENE SALVATO L'IDENTIFIER, L'ADDRESS E IL VALUE CHE SI TROVA NELL'INDIRIZZO DELL'ADDRESS.
			*** ATTENZIONE: L'IDENTIFIER E' ASSOCIATO ALL'ADDRESS, NON DIRETTAMENTE AL VALUE
			IL VALUE REFERENZIATO DA UN ADDRESS NON PUO' ESSERE MODIFICATO, E' IMMUTABLE ! 
			QUANDO DICHIARO CHE UNA VARIABILE E' UGUALE A UN ALTRA VARIABILE DI TIPO PRIMITIVE IN PRATICA ASSEGNO AL NUOVO IDENTIFIER LO STESSO ADDRESS DEL PRIMO. 
			QUANDO PERO' CAMBIO IL VALORE, SICCOME IL VALUE DELL'ADDRESS E' IMMUTABLE (PERCHE' ?), VIENE ALLOCATA DELL'ALTRA MEMORIA COL NUOVO VALORE, E QUINDI UN NUOVO ADDRESS 
		. I TIPI REFERENCE (object, function, Array, altro..) SONO MEMORIZZATI NELL'HEAP
			PER OGNI OGGETTO VIENE SALVATO NELL'HEAP L'ADDRESS E IL VALUE ALL'INDIRIZZO INDICATO DALL'ADDRESS 
			MENTRE NEL CALL STACK VIENE SALVATO L'IDENTIFIER, L'ADDRESS CHE PUNTA A UN INDIRIZZO DI MEMORIA CHE CONTIENE IL VALUE, CIOE' L'ADDRESS DELL'HEAP IN CUI C'E' L'INDIRIZZO DEL VALUE 
			GLI OBJECT SONO SALVATI NELL'HEAP PERCHE' POSSONO ESSERE TROPPO GRANDI PER STARCI NELL CALL STACK. 
			QUANDO DICHIARO UN NUOVO OGGETTO = UN ALTRO OGGETTO GIA' ESISTENTE, DI FATTO VIENE CREATO UN NUOVO IDENTIFIER CHE, NEL CALL STACK, PUNTA ALLO STESSO ADDRESS DEL PRIMO OGGETTO, CHE COME VALORE HA L'ADDRESS DELL'HEAP IN CUI SI TROVANO LE PROPRIETA' DEL PRIMO OGGETTO. 
			QUANDO MODIFICO UNA PROPERTY DEL SECONDO OGGETTO, VIENE MODIFICATO L'OGGETTO NELL HEAP, CHE NON E' IMMUTABLE A DIFFERENZA DEL CALL STACK, PER CUI VIENE CAMBIATO L'OGGETTO INIZIALE, PERCHE' E' SEMPRE QUELLO ! DAL PUNTO DI VISTA DEL CALL STACK LA MODIFICA ALLA PROPERTY DELL'OBJECT NON HA CAMBIATO NULLA, E' RIMASTO IMMUTABLE. 
			DI FATTO HO DUE IDENTIFIER CHE PUNTANO ALLO STESSO VALUE NEL CALL STACK, CHE E' L'INDIRIZZO DI MEMORIA DELL'HEAP IN CUI SI TROVANO I VALORI DELL'OGGETTO.  
			QUINDI SONO IMMUTABILI SOLO LE VARIABILI CON TYPE PRIMITIVI MENTRE GLI OBJECT (QUINDI ANCHE FUNCTION, ARRAY, ECC.. ) SONO MUTABLE. 
			E' IL MOTIVO PER CUI POSSO DICHIARE UN OGGETTO CON CONST (ANCHE UN ARRAY..) MA POSSO POI MODIFICARNE LE PROPERTY: QUANDO MODIFICO, MODIFICO L'HEAP, NON IL CALL STACK. 
			QUANDO INVECE PROVO AD ASSEGNARE UN NUOVO OGGETTO ALL'OGGETTO DEFINITO CON CONST RICEVO UN ERRORE, PERCHE' STO TENTANDO DI ASSEGNARE UN NUOVO HEAP ADDRESS AL RIFERIMENTO NELL'ADDRESS DEL CALL STACK, MA AVENDOLO DEFINITO CONST E' IMMUTABILE. PER POTERGLI ASSEGNARE UN NUOVO OGGETTO DEVO DEFINIRLO CON LET. 
			
			NOTA BENE: PER ESEGUIRE UNA COPIA DI UN OGGETTO USARE LA FUNZIONE Object.assign CHE CONCATENA IL PRIMO OGGETTO COL SECONDO E RESTITUISCE UN OGGETTO RISULTANTE, IL TRUCCO E' PASSARE UN OGGETTO VUOTO E POI L'OGGETTO DA COPIARE: 
				const nuovo oggetto = Object.assign({empty-objecty},oggetto-da-copiare) 
				
				NOTA BENE: QUESTA COPIA PERO' ESEGUE SOLO COPIA DI PRIMO LIVELLO (SHALLOW COPY), CIOE' NON CREA COPIE DI EVENTUALI OGGETTI NELL'OGGETTO E COSI' VIA. 
				PER FARE QUESTA COPIA COMPLETA (DEEP CLONE) NON C'E' UN ISTRUZIONE SEMPLICE, MA SI USA UN TOOL ESTERNO (DA COMPLETARE)  
	 
	**** ALTRE ISTRUZIONI PER ARRAY ****		
		** DESTRUCTURING ARRAYS (ES6 FEATURE) : RIDURRE IL CONTENUTO DI ARRAY O OBJECT IN VARIABILI PIU' SEMPLICI, IN ALTRO MODO, CERCARE ELEMENTI SPECIFICI IN UN ARRAY E SALVARLI IN APPOSITE VARIABILI 
			const array = [1,2,3];		// LA PRESENZA DELLE PARENTESI QUADRE A SX DELL'= FA CAPIRE A JS CHE VOGLIO IL DESTRUCTURING DELL'ARRAY A DX 
			const [a,b,c] = array;		// ESTRAGGO TUTTI E TRE GLI ELEMENTI DELL'ARRAY IN TRE VARIABILI
			const [a,,b] = array;       // PER SALTARE ELEMENTI LASCIARE VUOTO TRA VIRGOLE, QUI SALTO IL SECONDO ELEMENTO DELL'ARRAY
			const [a,b] = array;		// PER PRENDERE SOLO I PRIMI N
				const array = [1,2,[3,4]];  // PRENDERE ARRAY DI ARRAY 
				const [a,b,[c,d]] = array 	
			const [a=1, b=1, c=1, d=1] = array; //IMPOSTARE VALORI DI DEFAULT PER ELEMENTI NON PRESENTI IN ARRAY IN INPUT, NELL'ESEMPIO IL QUARTO ELEMENTO DELL'ARRAY NON C'E' PER CUI D = 1
			
		** DESTRUCTURING OBJECTS (ES6): STESSA COSA DEGLI ARRAY MA COL VANTAGGIO CHE NON DEVO RISPETTARE L'ORDINE DELLE PROPERTIES. 
				QUANDO DICHIARO USO PARENTESI GRAFFE INVECE CHE QUADRE
				PER LE VARIABILI DEVO USARE GLI STESSI NOMI DELLE PROPERTY 
				NON DEVO RISPETTARE L'ORDINE DI DICHIARAZIONE DELLE PROPERTY NEGLI OGGETTI ! NON E' POSIZIONALE !
			const mioObj = {
			  propA: "ciao",
			  propB: "da",
			  propC: "giggi"
			}
			const { propA, propB, propC } = mioObj;
			const { propC, propA, propB } = mioObj;  // STESSA COSA ! NON E' POSIZIONALE !
			console.log(propA, propB, propC);
				
				SE VOGLIO USARE NOMI DIVERSI DALLE VARIABILI: 
			const { propA: property1, propB: property2, propC: property3 } = mioObj;
			console.log(property3, property2, property1);
				
				IMPOSTARE VALORI DI DEFAULT ALLE PROPERTY DEGLI OGGETTI, POSSO ANCHE CAMBIARE NOME NELLO STESSO MOMENTO !
			const {
			  propA: property1,
			  propB: property2,
			  propertyZZ: giggi = 'forza milan',	// propertyZZ non esiste nell'oggetto mioObj per cui gli assegno il valore 'forza milan' e gli cambio anche il nome in giggi (non ha molto senso..) 
			} = mioObj;
				
				SE VOGLIO MUTARE DELLE VARIABILI PRECEDENTEMENTE DICHIARATE CON LE VARIABILI DESTRUTTURATE DEVO RACCHIUDERE CON PARENTESI TONDA: 
			let a = 111;
			let b = 222;
			const obj = { a: 20, b: 30, c: 40 };
			({ a, b } = obj);		// RIASSEGNO A E B CON I NUOVI VALORI PRESI DALL'OGGETTO DESTRUTTURATO, DEVO USARE LE PARENTESI TONDE ALTRIMENTI OTTENGO ERRORE "Unexpected token.." 
			console.log(a, b);			
				
				SE DEVO DESTRUTTURARE UN OGGETTO CONTENUTO DENTRO UN ALTRO OGGETTO: 
			const mioObj = {
			  mioSubObj: {
				prop1: 10,
				prop2: 20,
			  },
			};
			const { mioSubObj: { prop1, prop2 } } = mioObj;		// DESTRUTTURO L'OGGETTO mioSubObj DENTRO DESTRUCTURING DI mioObj CHE LO CONTIENE 
			console.log(prop1, prop2);
				
				OGGETTI PASSATI A METODI O FUNCTION COME ARGOMENTI E COME DESTRUTTURARLI, POSSO IMPOSTARE VALORI DI DEFAULT, CAMBIARE NOME ECC.. 
			function provaDestr({
			  attr1: a = 'FORZA',
			  attr2: b = 'MILAN',
			  attr3: { uno, due } = { uno: 'DAJE', due: 'MEJO' },			// SE NON VIENE PASSATO attr3 IMPOSTO PER VALORE DI DEFAULT UN OGGETTO CON I DUE ATTRIBUTI VALORIZZATI
			  attr4 = '!!!',
			}) {
			  console.log(a, b, uno + 'gggg' + due, attr4);
			}
			provaDestr({
			  attr1: 'ciao',
			  attr2: 'da',
			  attr3: {
				uno: 'gig',
				due: 'gi',
			  },
			});
			provaDestr({
			  attr4: 'EJA EJA !!!',
			});
		
		** SPREAD OPERATOR (... A DX =) E' UN SIMBOLO (I TRE PUNTINI) CHE RAPPRESENTA TUTTI GLI ELEMENTI DI UN ARRAY, SENZA BISOGNO DI ELENCARLI 
			I TRE PUNTINI SONO SPREAD QUANDO SONO A DESTRA DELL' = 
				SE SONO A SINISTRA ALLORA E' REST PATTERN (VEDI CAPITOLO SEGUENTE)
			E' COME FARE DESTRUCTURING DI UN ARRAY, NEL SENSO CHE "ESTRAE", ESPANDE, TUTTI GLI ELEMENTI DI UN ARRAY, MA SENZA LA POSSIBILITA' DI VALORIZZARE ALTRETTANTE VARIABILI. 
			FUNZIONA NON SOLO PER GLI ARRAY MA IN GENERALE PER TUTTI GLI ITERABLES JAVASCRIPT (arrays, strings, maps, sets, MA NON OBJECT !)
			FUNZIONA ANCHE SUGLI ARGOMENTI DI FUNZIONI: SCOMPONE UN ARRAY PASSATO COME ARGOMENTI IN SINGOLI ELEMENTI 
			NOTA BENE: LO SPREAD SI PUO' USARE SOLO PER CONVERTIRE ITERABLES E SUGLI ARGOMENTI DI UNA FUNCTION !
			NOTA BENE2: DA ES 2018 SPREAD SI PUO' USARE ANCHE CON OBJECT, ANCHE SE NON SONO ITERABLES !!
			
			const mioarray = [5, 6, 7];
			const nuovoArray = [1, 2, 3, ...mioarray]; // AGGIUNGO TUTTI GLI ELEMENTI DI mioarray			
				
				AGGIUNGO UN NUOVO ELEMENTO ALLA FINE DI UN ARRAY ESISTENTE 			
			const newArray = [...nuovoArray, 8, 9, 10];
			
				USO SPREAD PER COPIARE UN ARRAY IN UN ALTRO, E' COME FARE Object.assign. (SHALLOW COPY, SOLO UN "LIVELLO")
			const newArray2 = [...newArray]; 
			
				CONCATENO DUE ARRAY 
			const newArray3 = [...newArray, ...newArray2]; //concateno due array
			
				ESEGUO SPREAD SU UNA STRINGA TRASFORMANDOLA IN ARRAY DI CARATTERI
			const stringa = "Ciao";
			const arrayStr = [...stringa];
			const arrayStr2 = [..."Ciao"]; 	// ANCHE COSI' 
			
				ESEGUO SPREAD SU UN ARGOMENTO DI UNA FUNCTION 
			console.log(...stringa);
			
				ESEGUO SPREAD PER CREARE UN NUOVO OGGETTO DA UN ALTRO E AGGIUNGERGI NUOVE PROPERTY 
			const obj1 = {
			  prop1: 'ciao',
			  prop2: 'da',
			  prop3: 'giggi',
			};

			const obj2 = { ...obj1, prop4: '!!!!' };				
			
				ESEGUO SPREAD PER FARE COPIA DI UN OGGETTO IN UN ALTRO (SHALLOW COPY, SOLO UN "LIVELLO") !
				
			const obj3 = { ...obj2 };
			
		** REST PATTERN (... A SX =)
			COME SPREAD, STESSI TRE PUNTINI MA SI USA A SINISTRA DELL = E HA EFFETTO CONTRARIO: UNISCE VARIABILI IN ARRAY. 
			FUNZIONA ANCHE CON GLI OGGETTI !
			FUNZIONA ANCHE NELLA DICHIARAZIONE DEGLI ARGOMENTI DI UNA FUNCTION: SIGNIFICA CHE ELEMENTI SINGOLI PASSATI AD UNA FUNCTION, NON IMPORTA QUANTI, VENGONO RAGGRUPPATI IN UN ARRAY 
			NOTA BENE: REST DEVE ESSERE L'ULTIMO ELEMENTO DEL DESTRUCTURING ALTRIMENTI ERRORE !
					   CI PUO' ESSERE UN SOLO REST IN UN DESTRUCTURING 
						
			const [a, b, ...altro] = [1, 2, 3, 4, 5];	// destructuring in cui a = 1, b = 2 e 3, 4, 5 vengono assegnati all'array altro 
			
			const arrayA = ['a', 'b', 'c'];
			const arrayB = ['d', 'e', 'f'];
			const [aa, , cc, ...resto] = [...arrayA, ...arrayB];    //combino spread, per unire i due array, e rest, per mettere d, e, f nell'array resto
			
			ESEMPIO CON OGGETTI: 
			let testjson = {	
			  "E": ["971"],
			  "C": ["443"],
			  "F": ["831", "719", "970"],
			  "G": ["111", "222"]
			};		
			const { G, ...objresto } = testjson;    // estraggo E dall'oggetto testjson e tutti gli altri oggetti li metto in objresto			
			
			ESEMPIO USO IN FUNCTION 			
			const add = function (...numbers) {		// dichiaro function che riceve N elementi e li impacca nell'array numbers 
			  console.log(numbers);
			}
			add(1, 2, 3, 4, 5);
			
			const x = [1, 2, 3];				
			add(...x);	// chiamo function add passando gli elementi dell'array x che ottengo facendo lo spread, e quando li riceve la function vengono nuovamente impaccati in array col rest 
			
			const testRest = function (primo, ...altri) {	// dichiaro function che accetta un parametro in primo e tutti gli altri nell'array altri
			  console.log(primo);
			  console.log(altri);
			}
			testRest(1, 2, 3, 4, 5);	// 1 viene assegnato a primo mentre 2,3,4,5 all'array altri 
			
	** SHORT CICUITING: && E || OPERATORS (AND E OR) 
		IN GENERALE GLI OPERATORI BOOLEAN SI POSSONO USARE ANCHE CON VALORI NON BOOLEAN E RESTITUISCONO VALORI NON BOOLEAN 
		|| (OR) : RESTITUISCE IL PRIMO VALORE TRULY DELL'ELENCO DI VALORI SEPARATO DA || 
		console.log(undefined || "Ciao")	RESTITUISCE CIAO PERCHE' IL PRIMO VALORE E' FALSY 
		console.log(undefined || 0 || '' || "Ciao" || 23)	RESTITUISCE CIAO PERCHE I PRIMI TRE SONO FALSY 
		
		VIENE UTILE PER RIMPIAZZARE IL TERNARY OPERATOR ( ? .. : ) NELL'ASSEGNARE VALORE A VARIABILE
		INVECE DI FARE COSI'
			const pippo = pluto ? pluto : "no pluto"; 	// se pluto non e' falsy uso pluto altrimento imposto "no pluto"
		FACCIO COSI'
			const pippo = pluto || "no pluto"		// restituisce il primo valore truly, quindi se pluto e' falsy restituisce "no pluto"
		MA ATTENZIONE, SE VALORE E' ZERO E' FALSY E QUINDI MI TORNA L'ALTRO !!! QUINDI CON I NUMBER IL SHORT CIRCUITING NON FUNZIONA COSI' COM'E' ! USARE INVECE ?? OPERATOR (VEDI SOTTO, SOLO DA ES2020!)
		
		&& (AND) : CONTRARIO DI OR, SE PRIMO VALORE E' FALSY LO RESTITUISCE SUBITO (NON HA SENSO CONTROLLARE GLI ALTRI PERCHE' IN UN "AND" BASTA UN FALSE PER METTERE TUTTO A FALSE) ALTRIMENTI PASSA ALL'ALTRO E COSI' VIA 
			const pippo = 0 && "ciao"; RESTITUISCE 0 PERCHE' FALSY 
		VIENE UTILE PER TESTARE SE UNA FUNZIONE ESISTE PRIMA DI INVOCARLA OPPURE PER VALORIZZARE UNA VARIABILE CON UN VALORE SE E' GIA' VALORIZZATA 
		INVECE DI FARE COSI': 
			if (aggiungiProdotto) {
				aggiungiProdotto("martello");
			}
		FACCIO COSI': 
			aggiungiProdotto && aggiungiProdotto("martello");	//SE IL PRIMO TERMINE DA' FALSY (PER ESEMPIO UNDEFINED PERCHE' LA FUNZIONE NON E' STATA DICHIARATA) L'EVALUATION DELL'ISTRUZIONE SI FERMA E NON ESEGUE LA FUNZIONE. ALTRIMENTI ESEGUE LA FUNZIONE. 
	
	** (ES2020) NULLISH COALESCING OPERATOR ?? 
		SI BASA SUL CONCETTO DI "NULLISH VALUE" = NULL, UNDEFINED (E BASTA!) 
			let pluto = 0;
			const pippo = pluto ?? 'no pluto';	// torna 0 perchè non è un nullish value, quindi è truthy
			
	** (ES2021) LOGICAL ASSIGNMENT OPERATORS 
		PER OR OPERATOR C'E' FORMATO ASSEGNAZIONE ACCORCIATO ||= 	EQUIVALE A variabile = variabile || altrovalore;
		PER ?? OPERATOR C'E' FORMATO ASSEGNAZIONE ACCORCIATO ??= 	EQUIVALE A variabile = variabile || altrovalore; MA FUNZIONA ANCHE CON ZERO !!
		PER && OPERATOR C'E' &&= 	EQUIVALE A variabile = variabile && altrovalore; //assegna altrovalore se variabile è truthy
			const obj1 = {
			  a: 'ciao',
			  b: 0,
			};

			const obj2 = {
			  a: 'ciao',
			};

			// uso logical assignment operator per assicurarmi che entrambi gli oggetti abbiamo property b

			// obj1.b ||= 10; // forma stringata di obj1.b = obj1.b || 10, ma attenzione non funziona se b = 0
			// obj2.b ||= 10;
			obj1.b ??= 10; // forma stringata di obj1.b = obj1.b ?? 10, nullish value quindi funziona con 0
			obj2.b ??= 10;
			console.log(obj1);
			console.log(obj2);
			
	** FOR-OF LOOP ON ARRAYS 
		VERSIONE SEMPLIFICATA DEL CICLO FOR SU UN ARRAY, NON SERVE INDICE ECC.. 
		SONO SUPPORTATI BREAK E CONTINUE !
			for (const elemento of array) {		//IN ELEMENTO HO L'ELEMENTO CORRENTE DI OGNI ITERAZIONE DEL LOOP 
				console.log(elemento);
			}
		PER AVERE ANCHE INDICE OLTRE A VALORE: 
			for (const item of array.entries()) {	// IN ITEM HO UN ARRAY DI 2 ELEMENTI IN CUI IL PRIMO E' L'INDICE E IL SECONDO IL VALORE 
				console.log(item);
			}
			for (const [i, valore] of array.entries()) {	// USO DESTRUCTURING PER ESTRARRE CIASCUN ELEMENTO DELL'ARRAY DI OGNI ENTRY IN UNA VARIABILE APPOSITA
				console.log(i+1, valore);
			}			
			
	** (ES6) ENHANCED OBJECT LITERALS 
		. PER DICHIARARE UNA PROPERTY DI OGGETTO = ALTROOGGETTO DICHIARATO PRIMA
				const objfuori = {
				...
				}		
			INVECE CHE 
				const obj = {
					...
					objfuori: objfuori,					
				}
			POSSO ABBREVIARE: 
				const obj = {
					...
					objfuori,
				}
		. DICHIARAZIONE ABBREVIATA METODO: 
				const obj = {
					...
					addProduct(a, b) {		// SENZA : function
					}
				}
		. COMPOSIZIONE DEL NOME DELLA PROPERTY 
			INVECE CHE AVERE IL NOME DELLA PROPERTY FISSO POSSO COMPORLO TRA PARENTESI QUADRE USANDO ``, ARRAY, CONCATENANDO ECC.. 
				const obj = {
					...
					[`property${1+1}`]: "ciao",
					
				}				
	
	** OPTIONAL CHAINING ?.
		? MESSO DOPO OGGETTO, ESEGUE QUANTO SCRITTO DOPO IL PUNTO SOLO SE OGGETTO NON NULLABLE (NON UNDEFINED E NON NULL). FUNZIONA SIA CON PROPERTY/OGGETTI CHE CON FUNCTION CHE CON ARRAY !
			const obj = {
			  a: {
				logga(uno, due) {
				  console.log(uno, due);
				},
			  },
			  b: {
				c: 'ciao',
			  },
			};
			obj.a.logga(1, 2);
			obj.b.logga?.(1, 2); //eseguo logga solo se non undefined e non null
			obj.c?.logga(1, 2); //eseguo logga solo se c non undefined e non null		
			
			const days = ['mon', 'tue', 'thu', 'wed', 'fri', 'sat', 'sun'];
			console.log('🎉 Orari Apertura 🎉');
			for (const day of days) {
			  const open = restaurant.openingHours[day]?.open ?? 'closed';		// se property day è presente ritorna open altrimenti ritorna "closed" 
			  console.log(`${day} - ${open}`);
			}			
			
			
			const users = [{ name: 'Giggi', email: 'giggi@giggi.it' }];		
			console.log(users[1]?.name ?? 'non esiste');			// esempio con array 
			
	** LOOPING OBJECTS 
		OBJECT NON SONO ITERABLE, COME GLI ARRAY, MA POSSO ITERARE IN MODO INDIRETTO SULLE KEY, SUI VALUE E SU ENTRAMBI. 
			* ITERARE SULLE KEY
				for (const day of Object.keys(openingHours)){
				  console.log(day);
				}				
				const properties = Object.keys(openingHours); 	// Object.keys restituisce array con i nomi delle property dell'oggetto in input 
				console.log(`ci sono ${properties.length} property`);
				
			* ITERARE SUI VALUES 
				const values = Object.values(openingHours);
				
			* ITERARE SU ENTRAMBI, CIOE' SUGLI ENTRIES 
				const entries = Object.entries(openingHours);	// restituisce array di array di 2 elementi: chiave e valore 
				for (const [key, { open, close }] of entries) {		// uso destructuring dell'array e poi dell'oggetto in value
				  console.log(key, open, close);
				}
				
			* NOTA BENE: ALTRO MODO NON SPIEGATO DAL CORSO: 
				const stores = {
				  "E": ["971"],
				  "C": ["443"],
				  "F": ["831", "719", "970"]
				};

				for (const key in stores) {
				  console.log(key, ...stores[key]);
				}
				
	** SETS 
		COLLECTION DI UNIQUE VALUES, NIENTE DUPLICATI. 
		SIMILE AGLI ARRAY, NIENTE KEYS, SUPPORTA ITERABLE, QUINDI ANCHE SET DI STRINGHE (LI SCOMPONE IN CARATTERI UNIVOCI)
		NON C'E' IL GET ! PERCHE' I SET NON SONO ARRAY, L'ORDINE NON E' IMPORTANTE.
		ESTREMAMENTE PERFORMANTI, FINO AL 10 VOLTE PIU' VELOCI DEGLI ARRAY !
		MIGLIORE USE CASE: ELIMINARE DUPLICATI DA ARRAY
			const ordersSet = new Set(['ciao', 'da', 'giggi', 'da', 'giggi']);
			console.log(ordersSet);   // doppioni eliminati !
			
			const giggi = new Set('giggi');
			console.log(giggi);   //restituisce 'g' 'i'
		DIMENSIONE: 
			ordersSet.size 		
		CHECK PRESENZA ELEMENTO 
			ordersSet.has('da') //torna true o false 
		AGGIUNGERE ELEMENTO 
			ordersSet.add('forza')
		ELIMINARE ELEMENTO 
			ordersSet.delete('giggi')
		SVUOTARE IL SET 
			ordersSet.clear();
		ITERARE
			for (const order of ordersSet) 
				console.log(order)
		USARE PER ELIMINARE DUPLICATI DA ARRAY IN ARRAY
			const arrayConDuplicati = ['aa', 'bb', 'aa', 'bb', 'cc'];
			const arrayUnique = [...new Set(arrayConDuplicati)];    //creo Set dell'array con duplicati e con l'operatore Spread lo espando in un array 		
		CONTARE QUANTI VALORI UNIQUE HA UN ARRAY 
			const numUnique = new Set(['ciao', 'da', 'giggi', 'da', 'giggi']).size;
			
	** MAPS 
		PER MAPPARE VALUES TO KEYS, COME GLI OGGETTI, MA SONO MOLTO MEGLIO, INFATTI KEY PUO' ESSERE DI QUALUNQUE TIPO, ANCHE BOOLEAN 
		SONO PIU' PERFORMANTI DEGLI OBJECT !
			NOTA BENE: KEY BOOLEAN TRUE E FALSE IN UN SET POSSONO ESSERE UTILI PER FARE GET IN BASE A RISULTATO BOOLEAN DI UN ESPRESSIONE: SE TRUE RITORNO UN VALORE DAL MAP, SE FALSE UN ALTRO 
		ISTANZIARE MAP VUOTO
			const rest = new Map();
		AGGIUNGERE ELEMENTO
			rest.set("ciao", "da giggi");
			rest.set(1, "forza");
			console.log(rest.set(2, "milan"));	// set ritorna ogni volta il contenuto del Map, quindi posso concatenare istruzioni set 
			console.log(rest.set("lista", [1, 2, 3]).set("altro", { nome: "giggi", email: "giggi@tin.it" }));
		AGGIUNGERE ELEMENTI USANDO IN INPUT UN ARRAY DI ARRAY DI DUE DIMENSION (KEY, VALUE)  
			const rest = new Map([
			  ["primo", "primo elemento"],
			  ["secondo", "secondo elemento"],
			])			
			NOTA BENE: L'ARRAY E' LO STESSO RESTITUITO DA Object.entries(oggetto) PER CUI SI PUO' CONVERTIRE UN OGGETTO IN MAP: 
			const objToMap = new Map(Object.entries(restaurant.openingHours));
			console.log(objToMap.get("thu"));
		GET 
			console.log("ciao", rest.get("ciao"));
			console.log(question.get(question.get('correct') === scelta));	// get di un boolean risultante dall'espressione ===, perchè in question c'è sia un entry con true che con false 
		CHECK PRESENZA ELEMENTO 
			rest.has("ciao");
		ELIMINARE ELEMENTO 
			rest.delete("ciao");
		DIMENSIONE: 
			rest.size 
		SVUOTARE IL MAP 
			rest.clear();
		USARE ARRAY COME KEY: DEVO DEFINIRE L'ARRAY IN UNA VARIABILE CHE POI USO SIA NEL SET CHE NEL GET, ALTRIMENTI NON FUNZIONA PERCHE' USERO' DUE OGGETTI ARRAY DIVERSI 
			const arr = [1, 2];
			rest.set(arr, "ciao");    //aggiungo elemento con chiave = array di due elementi 
			console.log(rest.get(arr));           // ottengo "ciao"
		USARE OGGETTI COME KEY 
			rest.set(document.querySelector("h1"), "intestazione H1");
			console.log(rest);
		ITERARE, SUPPORTA ITERABLE E QUINDI FOR..OF 
			const question = new Map([
			  ['question', 'What is the best programming language in the world?'],
			  [1, 'C'],
			  [2, 'Java'],
			  [3, 'JavaScript'],
			  ['correct', 3],
			  [true, 'Correct 🎉'],
			  [false, 'Try again!'],
			]);		
			for (const [key, value] of question) {
			  if (typeof key === 'number') console.log(key, value);
			}
		CONVERTIRE OGGETTO IN MAP 
			const objToMap = new Map(Object.entries(restaurant.openingHours));
		CONVERTIRE MAP IN ARRAY 
			const mapToArray = [...question];		
		ITERARE SULLE KEY
			mappa.keys()							
		ITERARE SUI VALUES 
			mappa.values()
		ITERARE SULLE ENTRIES 
			mappa.entries()
	
	** STRINGS 
		LE STRINGHE SONO COME ARRAY, POSSO OTTENERE L'IESIMO CARATTERE CON [posizione] E LA LUNGHEZZA CON .lenght 
		*** NOTA BENE: QUANDO SI LAVORA CON LE STRINGHE IN INPUT, PER ESEMPIO IN UNA FUNCTION, PRIMA DI TUTTO CONVERTIRE IN LOWERCASE !!!
			const prova = "ciao ciao";
			console.log(prova[0]);
			console.log(prova.length);
			console.log("ciao"[3]);
			console.log("ciao".length);				
		STRING METHODS: 
			indexOf('r') 		PRIMA POSIZIONE STRINGA IN STRINGA, CASE SENSITIVE
			lastIndexOf('r') 	ULTIMA POSIZIONE STRING IN STRINGA, CASE SENSITIVE 
			slice(posizione_start, posizione_end(nonincluso!!))	SUBSTRING DA POSIZIONE IN INPUT, USARE INDEXOF !, INDICI PARTENDO DA ZERO 
			slice(posizione_negativa)		SUBSTRING DAL FONDO MENO I CARATTERI INDICATI, ESEMPIO -2 PARTE DAL PENULTIMO CARATTERE 			
			slice(posizione_start, posizione_end_negativa)	SUBSTRING DA POSIZIONE IN INPUT A POSIZIONE END PARTENDO DAL FONDO MENO CARATTERI INDICATI 
			toLowerCase()		CONVERTE IN MINUSCOLO 
			toUpperCase()		CONVERTE IN MAIUSCOLO
			trim()				TOGLIE SPAZI E RITORNI A CAPO (\n) ALL'INIZIO E ALLA FINE DELLA STRINGA 
			(ES2019) trimStart() trimEnd()
			replace(stringa-da-rimpiazzare, stringa-sostitutiva) 
				USE CASE: CAPITALIZE STRINGA (PRIMO CARATTERE MAIUSCOLO, RESTO MINUSCOLO): stringa.replace(stringa[0], stringa[0].toUpperCase()))
				MEGLIO: stringa[0].toUpperCase() + stringa.slice(1)  //dopo aver convertito stringa in minuscolo !
			replace(/espressione-regex/g, stringa-sostitutiva) 	// USARE REGEX PER SOSTITUIRE TUTTE LE RICORRENZE, TIPO REPLACEALL, /g = global 
				const boh = "forza milan milan milan";
				console.log(boh.replace(/milan/g, "giggi"));			
			(ES2021) replaceAll 	COME REPLACE MA SU TUTTE LE RICORRENZE (FUNZIONA!!!) 
			includes(stringa) 	RITORNA TRUE SE LA STRINGA CONTIENE stringa 
			startsWith(stringa) RITORNA TRUE SE LA STRINGA INIZIA CON stringa
			startsEnd(stringa) RITORNA TRUE SE LA STRINGA FINISCE CON stringa
			split(carattere/stringa)	SUDDIVIDE STRINGA IN INPUT IN UN ARRAY IN BASE AL CARATTERE INDICATO COME DELIMITATORE 
			array.join(carattere/stringa) UNISCE TUTTI GLI ELEMENTI DELL'ARRAY SPAZIANDOLI COL CARATTERE INDICATO. 
			padStart(lunghezza, carattere) AGGIUNGE CARATTERE IN TESTA ALLA STRINGA FINO AL RAGGIUNGIMENTO DELLA LUNGHEZZA INDICATA 
			padEnd(lunghezza, carattere) AGGIUNGE CARATTERE ALLA FINE DELLA STRINGA FINO AL RAGGIUNGIMENTO DELLA LUNGHEZZA INDICATA 
			repeat(numerovolte)		RIPETE LA STRINGA IN INPUT PER IL NUMERO DI VOLTE INDICATO 
		CONVERTIRE NUMERO IN STRINGA
			const stringa = number + '';
			
	** FUNCTIONS !
		ARGOMENTI CON VALORI DI DEFAULT 
				const createBooking = function (flightNumber, numPassengers = 1, price = 199) {
			OLTRE A INIZIALIZZARE SI POSSONO ANCHE USARE ESPRESSIONI IN CUI SI POSSONO USARE GLI ALTRI ARGOMENTI (ESPRESSIONI USATE OVVIAMENTE QUANDO L'ARGOMENTO NON E' STATO PASSATO!)
				const createBooking = function (flightNumber, numPassengers = 1, price = 199*1,2*numPassengers) {
			PER EVITARE DI PASSARE UNO O PIU' PARAMETRI, SOSTITUIRLI CON undefined: VIENE APPLICATO IL DEFAULT, SE E' STATO IMPOSTATO 
		
		PASSARE PARAMETRI BY REFERENCE E BY VALUE: 
			* PASSARE UN PRIMITIVE AD UNA FUNCTION E' COME PASSARNE UNA COPIA, QUINDI BY VALUE: MODIFICHE AL PRIMITIVO NELLA FUNCTION NON SI RIFLETTONO SUL PRIMITIVE DI PARTENZA
			* PASSARE UN OGGETTO E' PASSARE IL REFERENCE: MODIFICARE L'OGGETTO NELLA FUNCTION VUOL DIRE MODIFICARE LO STESSO OGGETTO FUORI DALLA FUNCTION (L'HEAP MODIFICATO E' LO STESSO!)
			NOTA BENE: IN REALTA' JAVASCRIPT PASSA SOLO BY VALUE, ANCHE QUANDO SEMBRA CHE PASSI IL REFERENCE ! CIOE': VIENE PASSATO L'ADDRESS CHE PERO' E' IL VALUE NELLO CALL STACK 
				==> (PER GLI OGGETTI) NEL CALL STACK VIENE SALVATO L'IDENTIFIER, L'ADDRESS CHE PUNTA A UN INDIRIZZO DI MEMORIA CHE CONTIENE IL **VALUE**, CIOE' L'ADDRESS DELL'HEAP IN CUI C'E' L'INDIRIZZO DEL VALUE
		(CONCETTO) FIRST-CLASS FUNCTION: TUTTE LE FUNCTION JAVASCRIPT SONO "FIRST-CLASS CITIZENS": SONO TRATTATE COME SEMPLICI VALUE, DI FATTO SONO UN TIPO DI DATO
			FUNCTION SONO OGGETTI, HANNO I LORO METODI, COME bind 
			POSSONO ESSERE ASSEGNATI A VARIABILI, PASSATI COME ARGOMENTI, RESTITUITI COME RISULTATO, ASSEGNATI COME METODO ALLA PROPERTY DI UN OGGETTO 
		HIGH-ORDER FUNCTIONS: UNA FUNCTION CHE RICEVE FUNCTION COME PARAMETRO O CHE RESTITUSCE UNA FUNCTION O ENTRAMBI 
				ESEMPIO: domobject.addEventListener(evento, function) 	addEventListener E' UN HIGH-ORDER FUNCTION PERCHE' IL SECONDO ARGOMENTO E' UNA FUNCTION, QUELLA CHE VOGLIO CHE VENGA ESEGUITA QUANDO SI VERIFICA L'EVENTO 
			CALLBACK FUNCTION: FUNCTION PASSATA COME PARAMETRO AD UNA HIGH-ORDER FUNCTION. SI DICE "CALLBACK" PERCHE' NON VIENE INVOCATA SUBITO MA IN UN SECONDO MOMENTO 
				LE CALLBACK SONO UTILI PER FARE ASTRAZIONE: LA FUNCTION HIGH-ORDER CHE RICEVE LA FUNCTION COME PARAMETRO NON HA IDEA DI COSA FACCIA, MA AD UN CERTO PUNTO LA ESEGUE. 
			PROPERTIES DELLE FUNCTION: 
				name 	NOME DELLA FUNCTION 
					const transformer = function (str, fn) {
						console.log(`Transformed by: ${fn.name}`);
					}
			ESEMPIO DI FUNCTION RESTITUITA DA FUNCTION 
				const ciao = function (saluto) {
					return function (nome) {
						console.log(`${saluto} ${nome} !`);
					}
				}
				const saluto = ciao("Hey ! ciao");
				saluto("Giggi");
				//oppure 
				ciao("Hey ! ciao")("giggi");
			CON ARROW FUNCTION
				const ciao = saluto => nome => console.log(`${saluto} ${nome} !`);
				ciao("Hola")("Pippo");
			PROBLEMA THIS USATO NEI METODI E UNDEFINED QUANDO SI INVOCA UNA REGULAR FUNCTION: 
				IN UN OGGETTO LE FUNCTION DICHIARATE SONO METODI E POSSONO ACCEDERE ALL'OGGETTO THIS CHE PUNTA ALL'OGGETTO E A TUTTE LE SUE PROPRIETA'. 
				IL DISCRIMINANTE E' COME INVOCO LA FUNCTION/METODO: SE LA INVOCO COME METODO (oggetto.function) ALLORA THIS SARA' PRESENTE E PUNTERA' ALL'OGGETTO. 
				MA SE COPIO LA FUNCTION/METODO IN UNA VARIABILE AL DI FUORI DELL'OGGETTO E POI INVOCO LA NUOVA FUNCTION, QUESTA DIVENTA REGULAR FUNCTION (NON PIU' METHOD QUINDI) E PERCIO' IL THIS E' UNDEFINES, PER CUI IL CODICE DELLA FUNCTION ANDRA' IN ERRORE. 
				CI VENGONO IN AIUTO I SEGUENTI METODI DI FUNCTION:
			METODI DELLE FUNCTION: 
			
				CALL: CON IL METODO CALL POSSO INVOCARE UNA FUNCTION CHE UTILIZZA AL SUO INTERNO IL THIS, INDICANDO NEL PRIMO ARGOMENTO A QUALE OGGETTO DEVE PUNTARE IL THIS. 
					IN PRATICA CON CALL POSSO INVOCARE UN METHOD INDICANDO L'OGGETTO A CUI DEVE AFFERIRE.
					const oggetto1 = {
						prop1: "ciao",
						method1(nome) {
							console.log(`${this.prop1} ${nome}`)
						}
					}
					oggetto1.method1("giggi");
					
					const oggetto2 = {
						prop1: "forza"
					}
					const method2 = oggetto1.method1;	//copio method1 in una variabile, diventa una regular function! 
					//method2("pippo");   // errore perché il this del metodo copiato è undefined quando la function è regular e non più method
					method2.call(oggetto2, "milan");	// CON call INDICO NEL PRIMO ARGOMENTO L'OGGETTO A CUI PUNTERA' IL THIS DI METHOD2 (CHE E' UNA COPIA DI OGGETTO1.METHOD1)
					oggetto1.method1.call(oggetto2, "ehila!");	// invoco direttamente method1 di oggetto1 però indicando che il this in esso deve puntare all'altro oggetto oggetto2 !
					ANCHE COSI' !! 
						const method = function (nome) {
							console.log(`${this.prop1} ${nome}`);
						}
						const oggetto1 = {
							prop1: "ciao"
						}
						const oggetto2 = {
							prop1: "forza"
						}
						method.call(oggetto1, "oggetto1 !");
						method.call(oggetto2, "oggetto2 !");

						poll.displayResults.call({ answers: [5, 2, 3] });
						poll.displayResults.call({ answers: [5, 2, 3] }, "string");
						
				APPLY: (NON PIU' USATO !) COME CALL MA GLI ARGOMENTI VANNO MESSI IN UN ARRAY 
						method.apply(oggetto1, ["oggetto1 !"]);
						method.apply(oggetto2, ["oggetto2 !"]);
						MEGLIO, USANDO SPREAD:
						method.call(oggetto1, ...["oggetto1 !"]);
						method.call(oggetto2, ...["oggetto2 !"]);
				BIND: IL PRIMO PARAMETRO E' L'OGGETTO (STRINGA, NUMERO, OGGETTO, ECC..) PER IL THIS, INFATTI NON INVOCA IL METODO MA RESTITUISCE UNA FUNCTION IN CUI IL THIS E' L'OGGETTO PASSATO IN INPUT, CHE POI POSSO INVOCARE PASSANDO GLI ARGOMENTI. POSSO PASSARE AL BIND ANCHE UNO O PIU' PARAMETRI DELLA FUNCTION DA INVOCARE !, POSSO ANCHE PASSARE IL THIS NULL E PASSARE GLI ALTRI PARAMETRI (SE NON MI SERVE NULL). 
						const method1 = method.bind(oggetto1)
						method1("oggetto1 !");
						const method2 = method.bind(oggetto2)
						method2("oggetto2 !");
					CON BIND POSSO ANCHE PREVALORIZZARE I PARAMETRI DEL METODO (NELL'ESEMPIO HO UN SOLO PARAMETRO..) 
						APPLICO IL PARADIGMA "PARTIAL APPLICATION": QUANDO UNA PARTE DEI PARAMETRI DI UNA FUNCTION SONO GIA' STATI IMPOSTATI
						method.bind(oggetto1, "oggetto1 !")();
						method.bind(oggetto2, "oggetto2 !")();
					USO BIND ANCHE QUANDO USO UN METODO IN UN DOM EVENT LISTENER E IN QUEL CONTESTO IL THIS NON PUNTA PIU' ALL'OGGETTO MA ALL'ELEMENTO DOM CHE HA TRIGGERATO L'EVENTO. 
						const lufthansa = {};

						lufthansa.planes = 300;
						lufthansa.buyPlane = function () {
							console.log(this);
							this.planes++;
							console.log(this.planes);
						}
						document.querySelector(".buy").addEventListener("click", lufthansa.buyPlane.bind(lufthansa));	//con bind specifico l'oggetto del this, mi ritorna la function che verrà invocata quando si verifica l'evento click 
					USO BIND ANCHE QUANDO HO UNA FUNCTION GENERICA E NE VOGLIO CREARE UNA PIU' SPECIFICA, CON UNO O PIU' PARAMETRI PREVALORIZZATI 
						const calcTassa = (perc, importo) => importo + importo * (perc / 100);
						console.log(calcTassa(19, 100));
						const calcTassaIVA = calcTassa.bind(null, 22);   //preimposto perc=22, il this non mi serve e lo imposto a null
						console.log(calcTassaIVA(100));					
		
		IMMEDIATELY INVOKED FUNCTION EXPRESSIONS (IIFE): E' UN PATTERN.
			SONO FUNCTION CHE VENGONO ESEGUITE IMMEDIATAMENTE UNA SOLA VOLTA, E POI NON POSSONO PIU' ESSERE INVOCATE. 
			IN PRATICA BISOGNA DICHIARARE LA FUNCTION SENZA UN NOME, USANDO IL TRICK DI SCRIVERLA DENTRO UN'EXPRESSION CIOE' DENTRO PARENTESI TONDE, ALTRIMENTI JAVASCRIPT SI INCAZZA:
				(function () {
					console.log("ciao");
				})();	//per invocarla basta mettere le parentesi ()
				(() => console.log("ciao"))();	// IN VERSIONE ARROW FUNCTION
			QUESTO PATTERN E' STATO CREATO DA QUALCHE DEVELOPER PER IMPLEMENTARE L'INCAPSULAMENTEO DI VARIABILI IN JAVASCRIPT: VISTO CHE LE FUNCTION HANNO IL LORO SCOPE, UNA FUNCTION "FINTA" COME QUELLA IIFE CI PERMETTE DI DICHIARARE VARIABILI PRIVATE, NON VISIBILI AL DI FUORI DELLO SCOPE DELLA FUNCTION IIFE. 
			MA DA ES6 E' STATO INTRODOTTO LO SCOPE BLOCK {...} CHE FA LA STESSA COSA, QUINDI DA ES6 LE FUNCTION IIFE NON SI USANO PIU'. 
			COMUNQUE UNA IIFE SI PUO' ANCORA USARE IN MODERN JS PER ALCUNI USE CASE: 
				- ESEGUIRE DEL CODICE SONO UNA VOLTA
				- ALTRO.. 
				
		CLOSURES: REGOLA GENERALE: UNA FUNZIONE HA ACCESSO AL VARIABLE ENVIRONMENT (VE) DELL'EXECUTION CONTEXT IN CUI E' STATA CREATA, ANCHE SE QUESTO EC NON E' PIU' NELLO CALL STACK ! 
			CLOSURE: VE ATTACCATO ALLA FUNCTION, ESATTAMENTE COM'ERA AL MOMENTO IN CUI LA FUNCTION E' STATA CREATA. DI FATTO LO SCOPE ORIGINARIO, AL MOMENTO DELLA CREAZIONE DELLA FUNCTION, E' STATO PRESERVATO NELLA CLOSURE ANCHE SE E' STATO DISTRUTTO PERCHE' LA FUNZIONE COLLEGATA (CHE HA CREATO LA "SOTTO" FUNZIONE) E' STATA ESEGUITA. 
			QUANDO JAVASCRIPT UTILIZZA UNA VARIABILE, PER PRIMA COSA VA A VEDERE NEL CLOSURE, ANCORA PRIMA DELLO SCOPE DELLA FUNCTION. 
			IL CLOSURE SOPRAVVIVE A TEMPO INDEFINITO DOPO L'ESECUZIONE DELLA FUNCTION. 
			IL CLOSURE PERMETTE L'ACCESSO A TUTTE LE VARIABILI (ANCHE GLI ARGOMENTI!) DELLA FUNCTION PARENT IN CUI LA FUNCTION E' STATA CREATA, ANCHE DOPO CHE LA PARENT FUNCTION E' TERMINATA COL RETURN. LA FUNCTION MANTIENE UN REFERENCE AL SUO OUTER SCOPE, IL CHE PRESERVA LO SCOPE CHAIN NEL TEMPO. 
			ATTENZIONE: LA CLOSURE VIENE CREATA PER TUTTE LE FUNCTION CREATE DENTRO UN'ALTRA FUNCTION, NON SOLO PER QUELLE RITORNATE INDIETRO !!
				PER ESEMPIO VIENE CREATA ANCHE PER LE FUNCTION INVOCATE DAL setTimeout DOPO X MILLISECONDI, IN QUESTO MODO QUESTE FUNCTION POSSONO ACCEDERE AL VE DELLA PARENT FUNCTION ESEGUITA E TERMINATA ANCHE PARECCHI SECONDI PRIMA. 
			*** UTILE console.dir(function) : MOSTRA INFO SU FUNCTION, NAME, LENGTH, E ANCHE SCOPE 
				SE ESEGUO console.dir SU FUNCTION CREATA IN UN'ALTRA FUNCTION, TRA GLI SCOPE VEDO ANCHE CLOSURE 
			CLOSURE DI UNA FUNCTION PUO' CAMBIARE NEL TEPMO, PER ESEMPIO QUANDO UNA FUNZIONE CREATA IN UNA FUNCTION PARENT VIENE RICREATA IN UN'ALTRA PARENT FUNCTION. IN QUESTO CASO LA CLOSURE AVRA' LE VARIABILI DELLA SECONDA PARENT FUNCTION E NON PIU' DELLA PRIMA. 
			
	*** ARRAY METHODS
		
		slice(indice_start, indice_end(nonincluso!!))	ESTRAE ELEMENTI ARRAY DA INDICE IN INPUT, RITORNA UN NUOVO ARRAY, NON MODIFICA ARRAY DI PARTENZA. ANCHE FINO A INDICE END, NON INCLUSO NELL'ESTRAZIONE. 
		slice(indice_negativa)		ESTRAE ELEMENTI ARRAY DAL FONDO MENO GLI ELEMENTI INDICATI, ESEMPIO -2 PARTE DAL PENULTIMO ELEMENTO
			console.log("ultimo elemento array: ", arr.slice(-1));
		slice(indice_start, indice_end_negativa)	ESTRAE DA indice IN INPUT A indice END PARTENDO DAL FONDO MENO ELEMENTI INDICATI
			TIP: slice SENZA PARAMETRI ESEGUE SHALLOW COPY
		
		splice	COME SLICE MA QUESTO MUTA L'ARRAY DI PARTENZA, NEL SENSO CHE SPOSTA GLI ELEMENTI DALL'ARRAY DI PARTENZA A QUELLO DI ARRIVO. DI SOLITO LO SI USA PROPRIO PER MODIFICARE L'ARRAY DI PARTENZA. TIPICO USE CASE: TOGLIERE L'ULTIMO ELEMENTO DI UN ARRAY
			arr.splice(-1)
		splice(indice_start, num_elem_delete) CANCELLA DALL'ELEMENTO CON INDICE START E PER IL NUMERO DI ELEMENTI INDICATO. RESTITUISCE ARRAY CON ELEMENTI CANCELLATI. 
		
		reverse INVERTE ORDINE ELEMENTI NELL'ARRAY. ATTENZIONE MUTA L'ARRAY !!
			arr.reverse()	MUTA arr INVERTENDO ORDINE ELEMENTI 
		
		concat 	CONCATENA ARRAY CON ARRAY IN INPUT. NON MUTA NIENTE !
			const arr3 = arr.concat(arr2);
			
		join RESTITUSCE UNA STRINGA CON TUTTI GLI ELEMENTI DELL'ARRAY CONCATENATI CON LA STRINGA IN INPUT 
			const str = arr3.join(" - ");
				
		at (ES2022) SERVE PER SPECIFICARE QUALE ELEMENTO SI VUOLE OTTENERE DALL'ARRAY, AL POSTO DELLA NOTAZIONE [indice]
			const elem = arr[0]; //solita notazione
			const elem = arr.at(0); //nuovo metodo 
			UTILE IN ALCUNE CIRCOSTANZE, COME USE CASE OTTENERE ULTIMO ELEMENTO, L'INDICE PUO' ESSERE NEGATIVO COME CON slice E QUINDI PASSANDO -1 OTTENIAMO L'ULTIMO ELEMENTO
			const ultimo = arr.at(-1);
			
			FUNZIONA ANCHE CON LE STRINGHE ! CHE SONO ARRAY !
			const ultimostr = "giggi".at(-1) //restituisce "i" 
			
		sort ! 
			
	** LOOPING ARRAY CON FOREACH
		array.forEach(callback(elemento))  E' UN METODO DEGLI ARRAY !! MA ANCHE DEI NODELIST RESTITUITI DA document.querySelector(All) 
			mioarray.forEach(elemento => console.log(elemento));
		array.forEach(callback(elemento,indice));		//versione con elemento e indice in input al callback
		array.forEach(callback(elemento,indice,array));	//versione con anche l'array completo
		NOTA BENE: CON forEach NON FUNZIONANO break e continue !!!!!
		
	** LOOPING MAP E SET CON FOREACH 
		map.forEach(callback(elemento, key, map))
		map.forEach(function (elemento, key, map) {
			console.log(key, elemento);
		});
		
		set.forEach(callback(elemento, key, map))  // uguale a map ! key = value !	PERCHE' NEI SET NON C'E' KEY O INDEX MA HANNO FATTO LA FIRMA FOREACH PER SET UGUALE ALLE ALTRE PER NON CREARE CONFUSIONE
		set.forEach(function (elemento, key, map) {
			console.log(key, elemento);
		});
		
		****************** NOTA BENE: USARE NOTATION _ PER VARIABILI INUTILI
		set.forEach(function (elemento, _, map) {
			console.log(key, elemento);
		});		
		
	** DATA TRANSFORMATION WITH MAP, FILTER, REDUCE ** 
		VANTAGGIO RISPETTO AD USARE FOR OF LOOP: SI POSSONO CONCATENARE TRA LORO !
		map 	e' UN METODO CHE RITORNA UN NUOVO ARRAY CONTENENTE I RISULTATI DELL'ESECUZIONE DELLA CALLBACK SU CIASCUN ELEMENTO DELL'ARRAY DI PARTENZA 
			const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
			// converto euro in dollari usando il metodo map 
			const eurToDollars = movements.map(euro => Math.round(euro * 1.1));		
		filter	RITORNA UN NUOVO ARRAY CONTENENTE SOLO GLI ELEMENTI DELL'ARRAY DI PARTENZA CHE SODDISFANO LA CONDIZIONE DEL FILTRO 
			// seleziono i soli importi maggiori di zero 
			const deposits = movements.filter(mov => mov > 0);	
		reduce	"riduce" GLI ELEMENTI DELL'ARRAY DI PARTENZA IN UN SINGOLO VALORE, PER ESEMPIO SOMMANDOLI TUTTI INSIEME MA ANCHE ALTRO ! QUINDI IL METODO RESTITUISCE UN VALORE, NON UN ARRAY !
			NOTA BENE: 
				* A DIFFERENZA DEGLI ALTRI METODI, IL CALLBACK DI REDUCE HA accumulator COME PRIMO PARAMETRO, LA VARIABILE CHE ACCUMULA L'OPERAZIONE RICHIESTA
				* OLTRE AL CALLBACK HA UN SECONDO PARAMETRO PER INIZIALIZZARE L'ACCUMULATOR 
			// somma tutti i valori di movements. in reduce accumula la sommatoria in acc, inizializzandolo a zero
			const balance = movements.reduce((acc, mov, i, arr) => acc + mov, 0);	
			// calcolo valore massimo con reduce
			const maxmov = movements.reduce((acc, mov) => mov > acc ? mov : acc, movements[0]);  //inizializzare acc col primo valore dell'array, non con zeroo !!
			// calcolo media di array di valori in humanAge
			const averageHumanAge = humanAges.reduce((acc, humanAge, i, arr) => acc + humanAge / arr.length, 0);
		
		I TRE COMANDI SI POSSONO CONCATENARE TRA LORO PERCHE' MAP E FILTER RESTITUISCONO L'ARRAY RISULTANTE. 
		ESEMPIO: DA ARRAY MOVIMENTI SELEZIONO DEPOSITI (> 0), LI CONVERTO IN DOLLARI (MOLTIPLICANDO PER 1.1) E SOMMO TUTTO CON REDUCE 
			const balanceUSD = movements.filter(mov => mov > 0).map(mov => Math.round(mov * 1.1)).reduce((acc, mov) => acc + mov, 0);

	*** ALTRI METODI DI ARRAY
		** FIND 
		array.find(callback(condizione)) restituisce il primo elemento dell'array che soddisfa la condizione indicata, non restituisce un array (come fa invece filter) 
			const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
			const firstWithdraw = movements.find(mov => mov < 0);
			console.log(firstWithdraw);  // mostra -400 
			
			NOTA BENE: torna undefined se la condizione non è soddisfatta ! cioè se non trova niente.
		
		** FINDINDEX 
		array.findIndex(callback(condizione)) restituisce l'indice del primo elemento dell'array che soddisfa la condizione indicata, non restituisce quindi l'elemento stesso ma il suo indice
			
			NOTA BENE: assomiglia a indexOf(valore) MA E' MOLTO PIU' ELASTICO, LA CONDIZIONE PUO' ESSERE QUALSIASI COSA, MENTRE INDEXOF MI DICE SOLO SE C'E' UN DETERMINATO VALORE. 

		** SOME 
		array.some(callback(condizione)) restituisce true se c'è almeno un elemento nell'array che soddisfa la condizione indicata. 
			const movements = [200, 450, -400, 3000, -650, -130, 70, 1300];
			const anyDeposits = movements.some(mov => mov > 0);
			console.log("deposits ? ", anyDeposits);
				restituisce true 
			
			NOTA BENE: simile a includes(valore) ma quest'ultimo funziona solo per equality. 
			
		** EVERY 
		array.every(callback(condizione)) restituisce true se TUTTI gli elementi dell'array soddisfano la condizione indicata
			const account4 = {
			  owner: 'Sarah Smith',
			  movements: [430, 1000, 700, 50, 90],
			  interestRate: 1,
			  pin: 4444,
			};		
			const allDeposits = account4.movements.every(mov => mov > 0);
			console.log("all deposits ? ", allDeposits);			
				restituisce true 
			
	*** NOTA BENE SU CALLBACK DEGLI ARRAY METHODS 
		SI PUO' DICHIARARE SEPARATAMENTE E POI RIUTILIZZARE CON PIU' METHODS: 
			const deposit = mov => mov > 0;
			console.log(movements.filter(deposit));
			console.log(movements.some(deposit));
			console.log(movements.every(deposit));
	
	*** ANCORA ALTRI METODI DI ARRAY 
		
		** FLAT 
		arr.flat(n-livello) restituisce un array risultante dal contenuto di tutti gli array dentro l'array. n.livello (default 1) indica di quanti livelli andare in profondita'. 
			const arr1 = [[1, 2, 3], [4, 5, 6], 7, 8];
			console.log(arr1.flat());		

			// accounts è un array di oggetti, ciascuno dei quali ha la property movements valorizzata con un array di movimenti 
			// per ottenere un array con tutti i movimenti di tutti gli account: 
			// uso map per ottenere un array di array e poi flat() per "spianare" tutto in un solo array 
			const allMovements = accounts.map(acc => acc.movements).flat();
			console.log(allMovements);			
		
			NOTA BENE: ESEGUIRE map E POI flat() E' MOLTO COMUNE, PER CUI ESISTE IL METODO flatMap CON PERFORMANCE MIGLIORI ! MA FUNZIONA SOLO SU 1 LIVELLO DI PROFONDITA' !
			
		** FLATMAP 
		arr.flatMap(callback(condizione)) esegue il map con la condizione indicata e poi sull'array risultante esegue il flat() 
		
			const allMovements = accounts.flatMap(acc => acc.movements);
			console.log(allMovements);
			
			NOTA BENE: FUNZIONA SOLO CON 1 LIVELLO DI PROFONDITA', SE DEVO ANDARE PIU' IN PROFONDITA' DEVO FARE map e poi flat(n-livello) 
			
			
	*** SORTING ARRAY 
		
		arr.sort() MUTA L'ARRAY DI PARTENZA ordina elementi dell'array in ordine alfabetico, TRATTA TUTTO COME STRINGHE QUINDI NON SORTA NUMERI CORRETTAMENTE 
		
		arr.sort((a,b) => {...}) PER SORTARE CON CRITERIO CUSTOM IN MODO ASCENDENTE. a = current value, b = next value 
			LA CALLBACK: 
				- SE RITORNA VALORE < 0 ALLORA A, B (MANTIENE L'ORDINE)
				- SE RITORNA VALORE > 0 ALLORA B, A (SWITCH TRA VALORI) 
				
			movements.sort((a, b) => {
			  if (a > b) return 1; // non importa che valore restituisco, basta che sia maggiore di 0, in tal caso i due valori vengono scambiati 
			  if (a < b) return -1; // idem come sopra, non importa il valore restituito basta che sia minore di 0, in tal caso i due valori sono già ordinati e rimangono come sono 
			})
			SEMPLIFICATO: 
			movements.sort((a, b) => a -b)
			
			PER ORDINARE IN MODO DESCRESCENTE BASTA INVERTIRE I VALORI RESTITUITI DALLA CALLBACK:
			movements.sort((a, b) => {
			  if (a > b) return -1; 
			  if (a < b) return 1; 
			})			
			
	*** CREARE ARRAY IN MODO PROGRAMMATICO 
		new Array(1,2,3,4,5) // crea un array con 5 elementi numerici 
		new Array(5) 	// crea un array con 5 elementi vuoti 
		
			NOTA : QUANDO ARRAY HA UN SOLO ARGOMENTO IN INPUT, VIENE INTESO COME IL NUMERO DI ELEMENTI DA INIZIALIZZARE. 
			NOTA2: UN ARRAY INIZIALIZZATO CON Array(n) E' POSSIBILE VALORIZZARLO CON fill(valore) 
			const arr3 = new Array(5)
			arr3.fill("ciao");
		
		** FILL 
		arr.fill(valore, pos-partenza, pos-fine-escluso) RIEMPIE L'ARRAY CON IL VALORE INDICATO, PARTENDO DALL'INDICE pos-partenza E FINENDO IN pos-fine-escluso SE INDICATI, ALTRIMENTI PARTE DA 0 
		
		** ARRAY.FROM()
		Array.from({length: x}, callback)	CREA ARRAY DI LUNGHEZZA x INIZIALIZZANDO GLI ELEMENTI CON L'ESECUZIONE DELLA CALLBACK (UGUALE A QUELLA DI MAP!)
			const arrx = Array.from({ length: 7 }, () => 1);	//crea array di 7 elementi inizializzati tutti con 1
			const arry = Array.from({ length: 7 }, (cur, i) => i + 1);   	// crea array di 7 elementi inizializzati  1,2,3,4,5,6,7
			
		Array.from(<NodeList o altri oggetti iterabili come Set Map ecc..>, callback map) CONVERTE OGGETTO IN ARRAY APPLICANDO PER OGNI ELEMENTO IL CALLBACK DI TIPO MAP
			const movementsUI = Array.from(document.querySelectorAll('.movements__value'))	//converte il NodeList restituito dal querySelectorAll in array
				NOTA BENE: LA STESSA COSA SI PUO' FARE CON 
					const movementsUI = [...document.querySelectorAll('.movements__value')]
				MA POI DEVO FARE IL MAP SEPARATAMENTE, MENTRE CON ARRAY.FROM FACCIO TUTTO IN UN UNICA ISTRUZIONE:
			const movementsUI = Array.from(document.querySelectorAll('.movements__value'), el => Number(el.innerT
			ext.replace(" €",""))) //converte il NodeList in array applicando la callback che toglie spazio€ e converte in numero
	
	*** OPERAZIONI MATEMATICHE 
	
		Math.sqrt(num) RADICE QUADRATA 
			NOTA BENE: num ** (1/2)   UGUALE !		
		num ** (1/3)   RADICE AL CUBO 		
		Math.max(elenco numeri)	NUMERO PIU' GRANDE 
		Math.min(elenco numeri)	NUMERO PIU' PICCOLO
		Math.PI  PI GRECO 
			Math.PI * Number.parseFloat("10px") ** 2
		
		// arrotondamento interi
		Math.trunc(numero intero): TRONCA I DECIMALI 
		Math.round(numero intero ): ARROTONDAMENTO MATEMATICO 
		Math.ceil(numero intero): ARROTONDAMENTO PER ECCESSO 
		Math.floor(numero intero): ARROTONDAMENTO PER DIFETTO
			NOTA BENE: floor e trunc danno lo stesso risultato con numeri positivi ma non con i negativi !!! trunc toglie semplicemente i decimali, floor con numero negativo arronda per eccesso (-23.3 > -24)
				In questo senso floor è meglio di trunc perché funziona con numeri positivi e negativi
		
		// arrotondamento numeri decimals 
		(numero).toFixed(num decimali) ARROTONDA ALLE CIFRE DECIMALI INDICATE
			ATTENZIONE: RESTITUISCE UNA STRINGA !! PER OTTENERE UN NUMERO METTERE + DAVANTI ESEMPIO: +(2.345).toFixed(2) 	RESTITUISCE NUMERO 2.35
			ATTENZIONE2: METTERE NUMERO TRA PARENTESI FA FARE BOXING A JS: QUINDI NUMERO PRIMITIVO DIVENTA OGGETTO E SU QUESTO OGGETTO VIENE INVOCATO METODO toFixed()
			
		%  REMAINDER OPERATOR 
			(5 % 2) = 1 IL RESTO DI 5/2  (2*2=4 + 1 = 5)
			
			NOTA: UTILE PER DETERMINARE EVEN/ODD (PARI/DISPARI)
			const isEven = n => n % 2 === 0;
		
		** NUMERIC SEPARATORS _ (DAL 2021) PER SCRIVERE NUMERI NEL CODICE IN MODO PIU' COMPRENSIBILE
			NON FORMATTA NIENTE !! E' SOLO PER LA LEGGIBILITA' DEL CODICE, NON FORMATTA A RUNTIME
			
			const diameterSolarSystem = 287_460_000_000;
		
		** COSTANTE Number.MAX_SAFE_INTEGER	9.007.199.254.740.991
		
		** BigInt n PER RAPPRESENTARE NUMERI GRANDI QUANTO VOGLIAMO 
			OPERATORE:   n alla fine del numero
			COSTRUTTORE: BigInt(numero) 
		console.log(111111111111111111111111111111111111111111n);
		console.log(BigInt(1111111111111111111111111111111111111111));	ATTENZIONE IL COSTRUTTURE BigInt NON RESTITUISCE LO STESSO RISULTATO DI 11111111111111111n !!! BOH. 
			
			NOTE: 
				. SI POSSONO FARE OPERAZIONI MATEMATICHE TRA NUMERI BIGINT 
				. NON SI POSSO FARE TRA BIGINT E NUMERI NORMALI, BISOGNA PRIMA CONVERTIRE IL NUMERO NORMALE IN BIGINT USANDO IL COSTRUTTORE 
				. SI POSSONO CONFRONTARE NUMERI BIGINT, ANCHE BIGINT E NORMALI MA ATTENZIONE, SE SI USA STRICT OPERATOR (=== ECC..) NON FUNZIONA PERCHE' I DUE TIPI NON SONO GLI STESSI 
				. UN BIGINT SI PUO CONCATENARE AD UNA STRINGA 
				. BIGINT NON FUNZIONANO CON LE FUNZIONI DI Math ESMPIO Math.sqrt(12n) RESTITUISCE ECCEZIONE
				. ATTENZIONE ALLE DIVISIONI TRA BIGINT: IL RISULTATO E' UN ARROTONDAMENTO. ESEMPIO 10n / 3n = 3 INVECE CHE 3.33.. I DECIMALI VENGONO TAGLIATI
				
	****** DATE !!! 
	
		** CREARE DATE, 4 MODI !
			1. new Date() 
				const now = new Date();
				console.log(now);
				Fri Jan 12 2024 11:04:04 GMT+0100 (Ora standard dell’Europa centrale)
				
			2. PARSING DI UNA STRINGA 
				const date = new Date('Fri Jan 12 2024 11:04:04');
				console.log(date);
				Fri Jan 12 2024 11:04:04 GMT+0100 (Ora standard dell’Europa centrale)
				
				LA STRINGA PUO' ESSERE PIU' O MENO LIBERA 
				const date = new Date('December 25 2023');
				console.log(date);
				Mon Dec 25 2023 00:00:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date('December 25 2023 11:30');
				console.log(date);
				Mon Dec 25 2023 11:30:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date('12 25 2023 11:30');
				console.log(date);
				Mon Dec 25 2023 11:30:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date('12/25/2023 11:30');
				Mon Dec 25 2023 11:30:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date('12.25.2023 11:30');
				Mon Dec 25 2023 11:30:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date('2019-11-18T21:31:17.178Z');		// FORMATO ISO   Z = UTC time 
				Mon Nov 18 2019 22:31:17 GMT+0100 (Ora standard dell’Europa centrale)
				
			3. COSTRUTTORE new Date(ANNO, MESE, GIORNO, ORA, MIN, SEC) 
				const date = new Date(2037, 10, 19, 15, 23, 5);
				Thu Nov 19 2037 15:23:05 GMT+0100 (Ora standard dell’Europa centrale)
					
					NOTA BENE: 
						. MESE E' ZERO BASED QUINDI 0=GENNAIO, 1=FEBBRAIO, 10=NOVEMBRE ECC.. 
						. JS AUTOCORREGGE ERRORI PER ESEMPIO 2020, 10, 31 VIENE CORRETTO IN PRIMO DICEMBRE PERCHE' NOVEMBRE HA SOLO 30 GIORNI 
						
			4. COSTRUTTORE new Date(timestamp unix time in MILLISECONDI !)		PARTE DAL 1 GENNAIO 1970 
				const date = new Date(0);
				Thu Jan 01 1970 01:00:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date(3 * 24 * 60 * 60 * 1000);  //tre giorni dopo 1 gen 1970   numgg * ore * min * sec * 1000 per convertire in millisecondi 
				Sun Jan 04 1970 01:00:00 GMT+0100 (Ora standard dell’Europa centrale)
				
				const date = new Date(1705055511000);
				Fri Jan 12 2024 11:31:51 GMT+0100 (Ora standard dell’Europa centrale)
				
		** METODI DELL'OGGETTO DATE 
			
			getFullYear		RITORNA ANNO  NOTA BENE: NON USARE GETYEAR() !!! 				
			getMonth()		RITORNA NUMERO MESE ZERO BASED 
			getDate()		RITORNA NUMERO GIORNO: NON TUTTA LA DATA !! 
			getDay()		RITORNA IL NUMERO DEL GIORNO NELLA SETTIMANA, PARTENDO CON 0=SUNDAY ECC...
			getHours()		RITORNA ORA
			getMinutes()    RITORNA MINUTI 
			getSeconds()	RITORNA SECONDI 
			toISOString()	FORMATTA NEL FORMATO ISO TIPO 2019-11-18T21:31:17.178Z		UTILE PER SALVARMI DATE DA QUALCHE PARTE 
			getTime()		RITORNA DATA IN TIMESTAMP MILLISECONDS 
			Date.now()		RITORNA TIMESTAMP DI ADESSO 
			
			setFullYear		IMPOSTA ANNO  NOTA BENE: NON USARE GETYEAR() !!! 				
			setMonth()		IMPOSTA NUMERO MESE ZERO BASED 
			setDate()		IMPOSTA NUMERO GIORNO
			setDay()		IMPOSTA IL NUMERO DEL GIORNO NELLA SETTIMANA
			setHours()		IMPOSTA ORA
			setMinutes()    IMPOSTA MINUTI 
			setSeconds()	IMPOSTA SECONDI			
				
				NOTA BENE: TUTTI QUESTI METODI HANNO AUTOCORRECTION, NEL SENSO CHE SE IMPOSTO 31 A NOVEMBRE LA DATA RISULTANTE E' 1 DICEMBRE 
			
		** INTERNATIONALIZATION 
			padStart
			
		** INTERNATIONALIZING DATES WITH INTL API 
			const now = new Date();
			const strDate = Intl.DateTimeFormat('en-US'(è il locale)).format(now);	//formatta data in formato en USA MM/GG/AAAA
			const strDate = Intl.DateTimeFormat('en-GB').format(now);	//formatta data in formato en GB  GG/MM/AAAA
			lista locale:  http://www.lingoes.net/en/translator/langcode.htm
			
			aggiungere orario e altre info con oggetto options: 
				NOTA: OPTIONS NON SERVE SE VOGLIO FORMATTATE SOLO DATA !
				const options = {
					hour: 'numeric',
					minute: 'numeric',
					day: 'numeric',
					month: 'long'  // scrive per esteso es. 'August'
					month: '2-digit' // scrive due cifre, padding con zero 
					year: 'numeric/2-digit'
					weekday: 'long'  // scrive giorno per esteso 
					anche short/narrow 
				}
				const strDate = Intl.DateTimeFormat('en-US',options).format(now);	//formatta data in formato en USA MM/GG/AAAA e ora 
			
			** OTTENERE LOCALE DA BROWSER 
			const locale = navigator.language;		// torna 'it' 
			const strDate = Intl.DateTimeFormat(locale,options).format(now);
			
	*** NUMBERS !! 
		const num = 3292892.10;
		new Intl.NumberFormat('en-US').format(num); //3,292,892.10
		new Intl.NumberFormat('de-DE').format(num); //3.292.892,10
		new Intl.NumberFormat(navigator.language).format(num); 
		
		const options = {
			style: "unit",
			unit: "mile-per-hour"
		}
		new Intl.NumberFormat(navigator.language, options).format(num); 	// 3,292,892.10 mph (esempio)

		const options = {
			style: "unit",
			unit: "celsius"
		}
		new Intl.NumberFormat(navigator.language, options).format(num); 	// 3,292,892.10 °C
		
		const options = {
			style: "percent",
			unit: "celsius" //ignorato
		}
		new Intl.NumberFormat(navigator.language, options).format(num); 	// 3,292,892.10 %
		
		const options = {
			style: "currency",
			unit: "celsius", //ignorato
			currency: "EUR", // NOTA BENE: BISOGNA SPECIFICARLO PERCHE' NON VIENE DETERMINATO IN AUTOMATICO DAL LOCALE, DAL COUNTRY
			useGrouping: false  //ATTIVA/DISATTIVA RAGGRUPPAMENTO CIFRE 
		}
		new Intl.NumberFormat(navigator.language, options).format(num); 	// 3,292,892.10 €
		
	*** SETTIMEOUT ! 
	
		setTimeout(callback, milliseconds, parametro1, parametro2, ...);		
			NOTA: I PARAMETRI ALLA CALLBACK LI PASSO DOPO MILLISECONDS !
		
		setTimeout(() => console.log('ciao'), 5000);
		
		const parole = ['da', 'giggi'];
		setTimeout((arg1, arg2) => console.log(`ciao ${arg1} ${arg2}`), 3000, ...parole);
		
		UN SETTIMEOUT SI PUO' ANNULLARE CON clearTimeout(nome-variabile-setTimeout) 
	
		if (parole.includes('giggi')) {
		  console.log("trovato giggi, spengo myTimer");
		  clearTimeout(myTimer);
		}	
		
	*** SETINTERVAL ! 
		ESEGUE CALLBACK OGNI X MILLISECONDS 
		setInterval(() => console.log(new Date()),1000);	// stampa data-ora ogni secondo 

	*** PROMISES 
		NOTA BENE: 
			SE ESEGUO UNA SERIE DI PROMISE UNO DIETRO L'ALTRO, CIASCUNO DIPENDENTE DALLA RISPOSTA DEL PRECEDENTE, NON INNESTARE UNO DENTRO IL THEN DELL'ALTRO MA METTERLI IN CHAIN. 
				DAL SECONDO FETCH DEVO RITORNARE IL SUO RISULTATO IN MODO CHE VENGA ELABORATO DAL THEN SUCCESSIVO
				fetch(API-1).then(data => {
					return fetch(API-2);
				}).then(data => {
					return fetch(API-3);
				}).then(data => {
					....
				});
				
		** MODI PER GESTIRE ERRORE PROMISE: 
			1. PASSARE UNA CALLBACK AL THEN COME SECONDO PARAMETRO (IL PRIMO E' LA CALLBACK PER LA GESTIONE DELL'OK
				.then(function(data) {
					//gestione OK 
				}, function(err) {
					//gestione KO
				});
				OPPURE:
				.then(data => //gestione OK, 
					  err => //gestione KO);				
				
			2. USARE UN UNICA ISTRUZIONE CATCH, PER CATCHARE TUTTI GLI ERRORI DELLA PROMISE, ANCHE QUANDO CE NE SONO N IN CHAIN !
				fetch(URL)	//restituisce promise
				.then(data => //gestione OK)
				.catch(err => //gestione KO);
				
			PER LA GESTIONE DELL'ERRORE MEGLIO PREPARARE UNA FUNCTION CHE IN INPUT HA IL MESSAGGIO E CHE POI MOSTRA IN UI 
				fetch(URL)	//restituisce promise
				.then(data => //gestione OK)
				.catch(err => renderError(err.message));			
				
				NOTA: err E' UN OGGETTO RESTITUITO DAL PROMISE, HA SEMPRE LA PROPERTY message 
				
			NOTA BENE: 
				fetch(URL)	//restituisce promise
				.then(data => //gestione OK)
				.catch(err => renderError(err.message));			
				.finally(() => ....) PER ESEGUIRE CODICE INDIPENDENTEMENTE DALL'ESITO DEL PROMISE 
						             PER ESEMPIO NASCONDERE UNO SPINNER CHE E' STATO MOSTRATO ALL'INIZIO DEL PROMISE 
				
			** ALL'INTERNO DEL THEN POSSO FARE IL THROW DI UN NUOVO ERRORE USANDO L'OGGETTO ERROR('MESSAGGIO')
				THROW TERMINA IMMEDIATAMENTE L'ESECUZIONE DELLA FUNCTION, COME FA RETURN. 
				ESEGUIRE UN THROW NEW ERROR DENTRO UN THEN PROVOCA LA REJECT CHE QUINDI FINISCE NEL CATCH !
					NOTA: ANCHE SE LO FA IL PRIMO THEN DI UNA CATENA, L'ESECUZIONE VIENE INTERROTTA, SKIPPA TUTTA LA CATENA E ARRIVA AL CATCH. 
					throw new Error('message') CREA UN OGGETTO err CON PROPERTY MESSAGE CHE VIENE QUINDI RESTITUITO DAL CATCH 
			
				if (...) 
					throw new Error('messaggio');
				
		** ESECUZIONE DELLE PROMISE CON L'EVENT LOOP
			LE PROMISE VENGONO ESEGUITE IN UNA CODA DEDICATA: MICROTASKS QUEUE, CHE HA PRIORITA' RISPETTO ALLA CALLBACK QUEUE (USATA PER ESEMPIO DAL SETTIMEOUT). 
			QUINDI A PARITA' DI CONDIZIONI, VENGONO ESEGUITE PRIMA TUTTE LE PROMISE IN CODA MICROTASKS, POI LE CALLBACK IN CALLBACK QUEUE. 
				QUINDI SE C'E' PROMISE CHE DURA MOLTO, RALLENTA ESECUZIONE DELLE CALLBACK ! 
				
		** CREARE PROMISE 
			const esempio = new Promise(function(resolve,reject) {		//= executor function
				....
				if (ok)
				   resolve(oggetto restituito al then)		//eseguo la resolve function (passata alla executor function) che marca la Promise come "fullfilled"
				else 
				   reject('oggetto restituito al catch (un messaggio)')		//eseguo la reject function (passata alla executor function) che marca la Promise come "rejected"
				   reject(new Error('messaggio))
			});
			
			esempio
				.then(res => console.log(res))
				.catch(err => console.error(err));
			
		** ASYNC FUNCTION E AWAIT
			CON async DICHIARO CHE UNA FUNZIONE E' ASINCRONA, GIRA IN BACKGROUND. 
				NOTA BENE: ASYNC FUNCTION TORNANO SEMPRE UN PROMISE !! QUELLO CHE RESTITUISCO CON RETURN VIENE TORNATO NEL PROMISE SUCCESSFULL (FULLFILLED) 
						   QUINDI L'INVOCAZIONE DI UNA ASYNC FUNCTION CHE RITORNA QUALCOSA DEVE ESSERE SEGUITA DA THEN.. 
				ATTENZIONE: SE AVVIENE ALL'INTERNO DELLA ASYNC FUNCTION AVVIENE UN ERRORE **CATCHATO**, LA PROMISE RESTITUITA NON SARA' IN CATCH MA SEMPRE IN THEN !!
					SE AVVIENE UN ERRORE CATCHATO CON TRY..CATCH, LA PROMISE RESTITUITA E' SEMPRE FULLFILLED 
					PER OTTENERE PROMISE IN ERRORE DEVO FARE IL RETHROW DELL'ERRORE DENTRO IL CATCH 
						   
			DENTRO LA FUNCTION POSSO AVERE UNO O PIU' await DI PROMISE 
			AWAIT STOPPA L'ESECUZIONE DELLA FUNCTION ASINCRONA FINCHE' LA PROMISE NON E' CONCLUSA. 
				NOTA: LO STOP DATO DALL'AWAIT NON BLOCCA TUTTO PERCHE' E' ALL'INTERNO DI UNA FUNCTION ASINCRONA ! NON BLOCCA IL CALL STACK DI JS. 
			
			IN PRATICA POSSO ESEGUIRE API ASINCRONE COME SE FOSSERO SINCRONE, SENZA THEN ECC.. ASSEGNANDO IL RISULTATO AD UNA VARIABILE. 
				ATTENZIONE: ASYNC/AWAIT E' UN MODO ELEGANTE PER ESEGUIRE PROMISE E THEN/CATCH SENZA USARLI DIRETTAMENTE. VENGONO COMUNQUE USATI DA JS 
				
			const whereAmI = async function (country) {
			  const res = await fetch(`https://countries-api-836d.onrender.com/countries/${country}`);
			  console.log(res);
			}
							
			** GESTIONE ERRORI. 
				SENZA THEN NON ABBIAMO IL CATCH, SERVE UN MODO PER INTERCETTARE ERRORI. 
				USARE try ...catch !
				
					try {
						const res = await fetch(`https://countries-api-836d.onrender.com/countries/${country}`);
						if (!res.ok) throw new Error('errore');
			
					} catch(err) {
						... faccio qualcosa in caso di errore 
					}
				
			** ESECUZIONE DI UNA ASYNC FUNCTION CHE ESEGUE RETURN DI PROMISE, DENTRO UNA IIFE (IMMEDIATELY INVOKED FUNCTION EXPRESSIONS (IIFE)) PER USARE AWAIT INVECE CHE THEN..CATCH
			(async function(){
				try{
					const res = await whereAmI();					
					console.log(res);
				} catch(err){
					console.error(err);					
				}
				console.log("roba da mostrare alla fine tipo finally")
			})();
			
			** ESECUZIONE DI PIU' PROMISE IN PARALLELO 
				Promise.all(array di promise) QUANDO I PROMISE NON DIPENDONO L'UNO DALL'ALTRO, DEVONO GIRARE IN PARALLELO ! ALTRIMENTI CON AWAIT VENGONO ESEGUITI UNO DOPO L'ALTRO.
					E' UN COMBINATOR 
					
				const data = await Promise.all(promise1, promise2, promise3, ecc.. è un array) 	//torna un nuovo promise 
					NOTA BENE: SE UNO DEI PROMISE VA IN ERRORE, TUTTO IL PROMISE.ALL VA IN ERRORE 
					
					ANCHE L'OGGETTO RESTITUITO E' UN ARRAY
				
			** ALTRI COMBINATOR 
				RACE 
					un promise = Promise.race(array of promise) 		RITORNA LA RISPOSTA (UN PROMISE) QUANDO IL PRIMO DEI PROMISE TERMINA BENE O MALE (QUINDI VINCE IL RACE )
														IL PROMISE CHE "VINCE" VIENE RESTITUITO COME RISULTATO, VINCE QUELLO CHE IMPIEGA MENO TEMPO, NON IMPORTA SE FINISCE BENE O MALE !
														
						RACE SI PUO' USARE PER GESTIRE UN TIMEOUT QUANDO SI USA UNA PROMISE, PER EVITARE CHE DURI TROPPO, MAGARI PERCHE' L'UTENTE HA POOR CONNECTION. 
						IN PRATICA AL RACE PASSO LA PROMISE CHE VOGLIO ESEGUIRE E UNA FUNCTION CHE RESTITUISCE UN PROMISE IN ERROR DOPO X SECONDI. 
						SE LA PROMISE VERA IMPIEGA PIU' TEMPO DELLA PROMISE COL TIMEOUT, LA RACE RESTITUIRA' IL PROMISE TIMEOUT 
						
						const timeout = function(sec) {
							return new Promise(function(_,reject) {			//non usando resolve sostituisco il parametro con _ ma è solo una convenzione per dire che non lo uso !
								setTimeout(function(){
									reject(new Error('request took too long!');
								},sec*1000);
							});						
						}
						
						Promise.race([promise..,timeout])
							.then(res => console.log(res))
							.catch(err => console.error(err));

				ALLSETTLED
					array of promise = Promise.allSettled(array of promise)		E' COME PROMISE.ALL SOLO CHE QUESTO NON APPLICA SHORT CIRCUIT, CIOE' ANCHE SE UNO O PIU' PROMISE VANNO IN ERRORE RITORNA L'ARRAY CON I PROMISE 	
					
				ANY 
					promise fullfilled = Promise.any(array di promise)			RITORNA IL PRIMO PROMISE FULLFILLED PIU' VELOCE(OK), E' SIMILE A RACE MA I PROMISE IN ERRORE VENGONO IGNORATI
					
					
	*** DOM 
	
		E' UN ALBERO COMPOSTO DA NODES. 
		OGNI NODE E' UN OGGETTO JS, 4 TIPI: 
			- ELEMENT 	QUALUNQUE ELEMENTO, P, DIV, ECC.. ESPONE MOLTI METODI E PROPERTIES: innerHTML, classList, children, parentElement, append(), remove(), insertAdjacentHTML(), querySelector(), closest(), matches(), scrollIntoView(), setAttribute() E MOLTI ALTRI !
				INTERNAMENTE HA ELEMENTO CHILD: HTMLElement
					IL QUALE HA ALTRI CHILD ELEMENT, UNO PER OGNI TIPO DI ELEMENTO CHE ESISTE IN HTML:
					- HTMLButtonElement
					- HTMLDivElement, 
					- HTMLLinkElement, 
					- .... 
					OGNUNO DI QUESTI CHILD HA UNIQUE METHODS E PROPERTIES !					
			- TEXT		ESEMPIO TAG P 
			- COMMENT	<!-- COMMENTO -->
			- DOCUMENT 	
			
		TUTTI I CHILD TYPES HANNO ACCESSO A METODI E PROPERTY DEI PARENT ELEMENTS TRAMITE L'EREDITARIETA' 
		QUINDI PER ESEMPIO UN HTMLButtonElement E' ANCHE UN HTMLElement E ANCHE UN Node
		
		IMPORTANTE: IL METODO querySelector() E' DISPONIBILE SIA NEL TIPO document CHE NEL TIPO ELEMENT (E QUINDI ANCHE NEI SUOI SOTTOTIPI) 
		
		NODE E' PARENT DI EventTarget 
		WINDOW E' PARENT DI EventTarget
		EventTarget E' L'OGGETTO ABSTRACT RADICE CHE ESPONE I METODI .addEventListener() e .removeEventListener() QUINDI TUTTI I SOTTOTIPI LI EREDITANO. 
				
		** SELEZIONARE ELEMENTI 
			document.documentElement		// document non è sufficiente per selezionare l'intero documento, per esempio per applicarvi un css, ma bisogno usare documentElement
			document.head 
			document.body
			document.querySelector(selettore) 		// restituisce primo elemento trovato 
			document.querySelectorAll(selettore) 	// restituisce NodeList con tutti gli elementi trovati 
			document.getElementById(id) 		 	// restituisce elemento con id specificato, senza indicare selettore #
			document.getElementsByTagName(tipo)		// restituisce HTMLCollection con gli elementi per tipo elemento in input (button, div, a, p, ecc..) 
													   IMPORTANTISSIMO: HTMLCollection è un tipo di elenco CHE VIENE AGGIORNATO AUTOMATICAMENTE quando cambia il DOM. 
															      Se per esempio elimino un bottone ed eseguo il metodo avrò l'elenco dei button SENZA quello che ho eliminato. 
																  Con NodeList non succede, avrò sempre lo stesso elenco, compreso l'elemento eliminato !
														          Può essere convertito in Array con Array.from, come NodeList 
            
			document.getElementsByClassName(class)	// restituisce HTMLCollection con elenco elementi con la classe in input, ANCHE QUESTO ELENCO SI AGGIORNA IN AUTOMATICO 
			
															
		** CREARE E INSERIRE ELEMENTI 
			elemento.insertAdjacentHTML(posizione, testo)	// inserisce testo nella posizione indicata (beforebegin, afterbegin, beforeend, afterend) 
			document.createElement(tipoElemento)			// crea un elemento del tipo indicato, per esempio div 
			element.classList								// restituisce elenco di classi dell'elemento 
			element.classList.add('nome-classe')			// aggiunge una classe all'elemento, vedi elenco metodi sopra cercando classList 
			element.prepend(elemento)						// aggiunge l'elemento come primo child di element 
			element.append(elemento)						// aggiunge elemento come ultimo child di element 
				NOTA BENE: UN ELEMENTO PUO' ESISTERE NEL DOM IN UN UNICO POSTO, NON IN PIU' POSTI SIMULTANEAMENTE, PER CUI SE ESEGUO PREPEND E POI APPEND DI UNO STESSO ELEMENTO, QUESTO VIENE POSTATO NEL DOM DALL'INIZIO ALLA FINE DI ELEMENT. PER COPIARE UN ELEMENTO, INVECE CHE SPOSTARLO, BISOGNA USARE cloneNode PER COPIARLO 
					element.prepend(elemento)
					element.append(elemento.cloneNode(true))	// se true clona anche tutti i child di elemento 
					
			element.before(elemento)						// inserisce prima 
			element.after(elemento)							// inserisce dopo 
			
		** DELETE ELEMENT 
			elemento.remove()								// NOTA: METODO NUOVO, PRIMA SI FACEVA element.parentElement.removeChild(element) 
			
		** STYLES ! 
			elemento.style.attributo=valore 				// VALORI DELLE PROPERTY DI STYLE SONO GLI STESSI CHE SI USA NEI CSS 
				message.style.backgroundColor = '#37383d';	
				message.style.width = '120%';				
					NOTA BENE: GLI STYLE IMPOSTATI CON L'ATTRIBUTO STYLE SONO "INLINE" STYLE, INSERITI DIRETTAMENTE NEL DOM DA ME IN MODO MANUALE, PROGRAMMATICO 
							   NEL CONSEGUE CHE SE USO STYLE.QUALCOSA PER LEGGERE UN ATTRIBUTO POTRO' LEGGERE SOLO QUELLI CHE HO IMPOSTATO MANUALMENTE E CHE SI VEDONO NEL DOM, TUTTI GLI ALTRI SARANNO VUOTI 
							   SE USO STYLE.QUALCOSA PER LEGGERE UN ATTRIBUTO DI UN CLASS IMPOSTATO COL CSS NON OTTERRO' NIENTE !
							   SE VOGLIO OTTENERE TUTTI GLI STYLE DI UN ELEMENTO DEVO USARE IL METODO (window.)getComputedStyle(elemento) CHE MI TORNA UN OGGETTO DI TIPO CSSStyleDeclaration CON TUTTE LE PROPERTY E I RELATIVI VALUE, NON SOLO QUELLE IMPOSTATE CON I CSS, ANCHE QUELLE CHE HA CALCOLATO IL BROWSER IN AUTONOMIA (DA CUI CALCULATED..) 
				message.style.height = parseFloat(getComputedStyle(message).height) + 40 + 'px'; //aggiunge 40 pixel all'height dell'elemento message calcolato dal browser 
				
			** CSS Custom Properties (vedi all'inizio) 
			Sono modificabili da JS : document.documentElement.style.setProperty(nomevariabile, valore);
				document.documentElement.style.setProperty('--color-primary', 'orangered');			
			Si possono usare in JS per impostare style, scrivendo var(--...) tra apici 
				element.closest('.header').style.background = 'var(--color-primary)';
							   
		** ATTRIBUTES 
			POSSO LEGGERE E MODIFICARE TUTTE LE PROPERTY STANDARD DI UN ELEMENTO CON LA SINTASSI elemento.attributo, MA NON QUELLI CUSTOM CHE HO INSERITO MANUALMENTE NEL CODICE HTML. 
				PER GLI ATTRIBUTI CUSTOM C'E' getAttribute('attributocustom')
				const logo = document.querySelector('.logo');
				logo.src 
					NOTA BENE: src e href restituiscono l'url assoluto, se voglio l'url relativo uso elemento.getAttribute('src') o elemento.getAttribute('href')
				logo.alt
				logo.className	// ritorna le classi dell'elemento, 
				SE LOGO HA L'ATTRIBUTO CUSTOM designer 
				logo.designer 	// restituisce undefined 
				logo.getAttribute('designer')	// RESTITUISCE IL VALORE ! 
				logo.setAttribute('writtenby', 'giggi')	// IMPOSTA ATTRIBUTO CUSTOM CON VALORE SPECIFICATO 
		
		** DATA ATTRIBUTES 
			SPECIALI ATTRIBUTI CUSTOM CHE INIZIANO CON data-
				esempio:  <button class="btn" data-user-tab="1" >
			USATI PER SALVARE NELLA UI INFORMAZIONI UTILI 
			PER INTERAGIRVI CON JS 
				elemento.dataset.attributoCustomSenzaDataInCamelCase :)
					console.log(button.dataset.userTab) //torna "1"
					
		** ROBA UTILE PER DIMENSIONE/POSIZIONE/VIEWPORT
			elemento.getBoundingClientRect()	// restituisce coordinate e distanze dell'elemento rispetto al viewport corrente 
			DEPRECATO: window.pageXOffset, window.pageYOffset	//posizione corrente del viewport visibile rispetto alla pagina (X = orizzontale, Y= verticale) 
			window.scrollX, window.scrollY	//posizione corrente del viewport visibile rispetto alla pagina (X = orizzontale, Y= verticale) 
			document.documentElement.clientHeight, document.documentElement.clientWidth	//dimensione corrente del viewport del contenuto (escluse scroll bars !)
			
			* ESEGUIRE SCROLL AD UNA POSIZIONE IN PAGINA
			window.scrollTo(elemento.left + window.pageXOffset, elemento.top + window.pageYOffset);		//metodo global per eseguire scroll ad una posizione (x, y), di solito quella di un elemento 
				MEGLIO, CON ANIMAZIONE: 
			window.scrollTo({
				left: elemento.left + window.scrollX,
				top: elemento.top + window.scrollY,
				behavior: 'smooth'		//tipo animazione: smooth, auto, instant
			});
				ANCORA MEGLIO: 
			elementotarget.scrollIntoView({
			    behavior: "smooth"
			});
			
	*** EVENTI 
			
		GLI EVENTI SI VERIFICANO ANCHE SE NON C'E' UN LISTENER DEDICATO A LORO. PER ESEMPIO IL CLICK DI UN BOTTONE VIENE TRIGGERATO QUANDO L'UTENTE CLICCA, ANCHE SE NON C'E' UN BUTTON.ADDEVENTLISTENER. 
			
		mouseenter 	SI VERIFICA QUANDO IL MOUSE "ENTRA" IN UN ELEMENTO 
			
		**	AGGIUNGERE UN EVENTLISTERER: 
			1. addEventlistener(tipoevento,callback,CAPTURING TRUE/(FALSE=DEFAULT)	NUOVA MANIERA, MIGLIORE PERCHE' 
																		POSSO AGGIUNGERE PIU' FUNCTION ALLO STESSO EVENTO MENTRE COL METODO 2 NON POSSO 
																		POSSO RIMUOVERE UN EVENTLISTENER DOPO AVERLO AGGIUNTO (COL METODO 2 NON SI PUO')
																		POSSO CONCATENARLO AL QUERYSELECTOR 
																		document.querySelector('.form').addEventListener('mouseover',function(e){...});
																		
					ROBA UTILE: 
					* this NELLA FUNCTION PUNTA ALL'ELEMENTO SUL QUALE HO FATTO ADDEVENTLISTENER
					* e.target PUNTA ALL'ELEMENTO DA CUI È PARTITO L'EVENTO, CHE PUÒ ESSERE DIVERSO DALL'ELEMENTO SUL QUALE È ATTIVO L'ADDEVENTLISTENER PER EFFETTO DEL BUBBLING (VEDI SOTTO) 
						CIOE' SE HO AGGIUNTO UN EVENT LISTENER CLICK AD UN TAG A E AL DIV CHE LO CONTIENE E CLICCO SULL'ANCHOR, IN ENTRAMBE LE FUNCTION e.target PUNTA ALL'ANCHOR MA IN CIASCUNA FUNCTION IL THIS PUNTA RISPETTIVAMENTE ALL'ANCHOR E AL DIV 
					* e.currentTarget = this = L'ELEMENTO SU CUI E' ATTACCATO L'EVENTLISTENER, CIOE' L'ELEMENTO ATTRAVERSATO DURANTE LA FASE DI BUBBLING 
					* IL TERZO PARAMETRO DI SOLITO NON SI METTE E IL DEFAULT E' FALSE: VUOL DIRE CHE L'EVENT LISTENER VERRA' CONSIDERATO NELLA FASE BUBBLING (IN RISALITA DOPO EVENT TARGET). 
						SE SPECIFICO TRUE, VERRA' INVECE CONSIDERATO NELLA PRIMA FASE, QUELLA DI CAPTURING, PRIMA DEL TARGET EVENT, IN "DISCESA". 
						IN REALTA' QUESTA COSA DEL CAPTURING E BUBBLING E' ROBA VECCHIA, RISALENTE A QUANDI I BROWSER GESTIVANO GLI EVENTI IN MODO DIVERSO. ORA NON E' PRATICAMENTE PIU' USATO. 
			2. elemento.on{evento} = function;		VECCHIA MANIERA
					elemento.onmouseenter = function(e) {
						...
					}
					elemento.onclick = function(e) {
						...
					}
			3. (VECCHISSIMO) IN HTML <h1 onclick="alert('ciao da giggi')" ... 
			
		** RIMUOVERE UN EVENT LISTENER: SI PUO' FARE SOLO CON EVENTLISTENER AGGIUNTI CON ADDEVENTLISTENER E CON NAMED FUNCTION 
			const clickOnButton = function(e) {
				//gestione click 
			}
			button.addEventListener('click, clickOnButton);
			
			button.removeEventListener('click', clickOnButton);		//SI' E' GIUSTO, SI PASSA LA STESSA FUNCTION CHE GESTISCE L'EVENTO 
			
		** PASSARE PARAMETRI ALL'EVENT LISTENER
			SE VOGLIO INVOCARE UNA NAMED FUNCTION, ESTERNA ALL'EVENT LISTENER INVECE CHE INVOCARE QUELLA ANONIMA, E PASSARLE DEI PARAMETRI NON LO POSSO FARE DICHIARANDO I PARAMETRI NELLA FUNCTION PERCHE' L'EVENT LISTENER SI ASPETTA UNA CALLBACK CON IL SOLO PARAMETRO DELL'EVENTO. 
			POSSO PERO' SFRUTTARE L'OGGETTO THIS DELLA FUNCTION ESTERNA, IMPOSTANDOLO E PASSANDO AL METODO BIND CHE MI RESTITUSCE UNA FUNCTION(E) CON IL THIS VALORIZZATO COME VOGLIO IO, CON TUTTI I PARAMETRI CHE VOGLIO !
			const handleClick = function(e) {		// devo per forza dichiarare solo il parametro e
				console.log(this.param);
			}
			elemento.addEventlistener('click', handleClick.bind({param: "giggi"});
			esecuzione: click su elemento
					     > giggi
						 
				const handleClick = function (e) {		// devo per forza dichiarare solo il parametro e
				  console.log(e.target.src, this.param);
				}
				document.querySelector('.nav__logo').addEventListener('click', handleClick.bind({ param: "giggi" }));						 
				console: http://127.0.0.1:5500/13-Advanced-DOM-Bankist/starter/img/logo.png giggi
			
		** BUBBLING AND CAPTURING 
			UN CERTO ELEMENTO SU CUI VOGLIO GESTIRE IL CLICK, PER ESEMPIO, E' SOTTO UNA CERTA GERARCHIA DI ELEMENTI PADRI. 
			* CAPTURING PHASE: 
				QUANDO CLICCO SU QUESTO ELEMENTO, L'EVENTO CLICK SI GENERA PER PRIMA COSA NELL'ELEMENTO RADICE (DOCUMENT), POI NELL'ELEMENTO SOTTOSTANTE (ELEMENT HTML), POI BODY, ECC.. FINO AD ARRIVARE ALL'ELEMENTO CHE E' STATO CLICCATO, IL **TARGET**. A QUESTO PUNTO..
			* TARGET PHASE 
				GLI EVENTI, TRA CUI IL CLICK, POSSONO ESSERE GESTITI SULL'ELEMENTO CON GLI EVENT LISTENER 
				POI..
			* BUBBLING PHASE 
				L'EVENTO CLICK RISALE IN MODO GERARCHICO FINO AL ROOT DEL DOM (MA NON SUI SIBLING !), E' COME SE FOSSE ACCADUTO ANCHE SU TUTTI I PARENT DELL'ELEMENTO DI PARTENZA.
				QUESTO VUOL DIRE CHE SE CI SONO EVENT LISTENER PER LO STESSO EVENTO SU UNO DEI PARENT, VENGONO ESEGUITI ANCH'ESSI !!
			* NOTA BENE: 
				DI DEFAULT GLI EVENT LISTENER OPERANO SOLO NEL BUBBLING PHASE MA SI POSSONO PREDISPORRE ANCHE PER STARE IN ASCOLTO DI EVENTI DURANTE IL CAPTURING PHASE (UNA SORTA DI "BEFORE"..).
				NON TUTTI GLI EVENTI SUPPORTATI DA JS HANNO CAPTURING E BUBBLING PHASE !
			
			****>  PROPAGATE = CAPTURING + BUBBLING !!!
			
			* INTERROMPERE LA PROPAGAZIONE E IL BUBBLING, MA ATTENZIONE, NON E' BEST PRATICA !!!!!!! SI FA SOLO IN SITUAZIONI PARTICOLARI DI COMPLESSITA'  
				e.stopPropagation();
				
			* IMPOSTARE ADDEVENTLISTENER SU CAPTURING INVECE CHE BUBBLING (DEFAULT), TERZO PARAMETRO ADDEVENTLISTENER = TRUE 
				elemento.addEventListener(evento, callback, true); 
				
				PRATICAMENTE CON TRUE L'EVENT LISTENER VIENE ESEGUITO IN "DISCESA", PRIMA DEL EVENT TARGET
				IN REALTA' QUESTA COSA DEL CAPTURING E BUBBLING E' ROBA VECCHIA, RISALENTE A QUANDI I BROWSER GESTIVANO GLI EVENTI IN MODO DIVERSO. ORA NON E' PRATICAMENTE PIU' USATO. 
				QUINDI 99 SU 100 SI USA FALSE (BUBBLING), OMESSO. 
				
		** EVENT DELEGATION
			SFRUTTO BUBBLING PHASE PER ATTACCARE UN EVENT LISTENER AD UN CONTAINER DEGLI ELEMENTI SUI QUALI VOGLIO GESTIRE L'EVENTO, INVECE CHE ATTACCARE UN EVENT LISTENER (E UNA FUNCTION UGUALE!) A CIASCUNO DI LORO. USANDO E.TARGET NELLA FUNCTION POSSO ACCEDERE ALLE PROPRIETA' DI CIASCUN ELEMENTO DA CUI E' PARTITO L'EVENTO, IN UN UNICO EVENT LISTENER ATTACCATO AL CONTAINER. 
			**> IMPORTANTE ! NELLA FUNCTION DELL'EVENTLISTENER DEVO ASSICURARMI CHE L'EVENT TARGET CHE STO ELABORANDO E' QUELLO GIUSTO, UN CONTAINER POTREBBE AVERE ELEMENTI DI TIPO DIVERSO, CON EVENTI DIVERSI. LO POSSO FARE PER ESEMPIO VERIFICANDO SE NELL CLASSLIST C'E' UNA CLASSE CHE LO IDENTIFICA. 
			I PASSI SONO: 
			1. ADD EVENT LISTENER TO THE COMMON PARENT ELEMENT 
			2. DETERMINE WHAT ELEMENT ORIGINATED THE EVENT (MATCHING STRATEGY) 
			IMPOSTARE CORRETTAMENTE UN MATCHING STRATEGY, QUINDI IDENTIFICARE L'ELEMENTO (TIPO UNA CLASSE) CHE IDENTIFICA IN MODO UNIVOCO GLI ELEMENTI DA ISOLARE, E' L'ELEMENTO PIU' COMPLESSO DELL'EVENT DELEGATION 
			
	** DOM TRAVERSING 
		PARTENDO DA UN ELEMENTO, SELEZIONARE ELEMENTO PADRE, GLI ELEMENTI FIGLI O QUELLI ALLO STESSO LIVELLO. RICORDIAMO CHE IL DOM E' UN ALBERO. COME IL DL1 :) TIPO GNP 
		
		* SCENDERE (CHILDREN)
		elemento.querySelectorAll(selettore) 	RESTITUISCE NodeList CON TUTTI GLI ELEMENTI CHE SODDISFANO IL SELETTORE E CHE SONO FIGLI ANCHE INDIRETTI DI ELEMENTO. 
		elemento.childNodes						RESTITUISCE NodeList CON I SOLI NODI DIRETTI FIGLI DI ELEMENTO, DI TUTTI I TIPI (TEXT, COMMENT, SPAN, ECC..) 
		elemento.children 						RESTITUISCE HTMLCollection CON I SOLI ELEMENTI DIRETTI FIGLI DI ELEMENTO, QUINDI SOLO DI TIPO ELEMENT 
		elemento.firstElementChild				RESTITUISCE IL PRIMO ELEMENT FIGLIO DIRETTO DI ELEMENTO, SAREBBE IL PRIMO RESTITUITO DA elemento.children
		elemento.lastElementChild				RESTITUISCE L'ULTIMO ELEMENT FIGLIO DIRETTO DI ELEMENTO, SAREBBE L'ULTIMOI RESTITUITO DA elemento.children
		
		* SALIRE (PARENTS) 
		elemento.parentNode						RESTITUISCE IL NODO PADRE DIRETTO
		elemento.parentElement					RESTITUISCE L'ELEMENTO PADRE DIRETTO 
		elemento.closest(selettore)				RESTITUISCE L'ELEMENTO PADRE DEL TIPO INDICATO DAL SELETTORE, DIRETTO O INDIRETTO, NON IMPORTA DI QUALE LIVELLO. ANCHE SE STESSO !
												PRATICAMENTE E' UGUALE A QUERYSELECTOR MA VERSO L'ALTO INVECE CHE VERSO IL BASSO 
			document.querySelector('.header__img').closest('.header').style.background = 'var(--color-tertiary)'
			h1.closest('h1') 	//TORNA SE STESSO 
		
		* STESSO LIVELLO (SIBLINGS) 
		elemento.previousElementSibling			ELEMENTO PIU' VICINO A "SINISTRA" 
		elemento.nextElementSibling				ELEMENTO PIU' VICINO A "DESTRA" 
		elemento.previousSibling				NODO PIU' VICINO A SINISTRA 
		elemento.nextSibling					NODO PIU' VICINO A DESTRA 
			NOTA BENE: NON ESISTONO METODI CHE RESTITUISCONO I SIBLING INDIPENDENTEMENTE DALLA LORO POSIZIONE. 
					   POSSO USARE IL TRUCCO DI RISALIRE AL PADRE E POI OTTENERE TUTTI I FIGLI 
					   elemento.parentElement.children 
					   esempio di modifica di tutti i sibling di un elemnto h1 ad eccezione di se stesso: 
					   // faccio spread di HTMLCollection in array e poi forEach
					   [...h1.parentElement.children].forEach(function(el){
						el !== h1 && el.style.transform = "scale(0.5)";
					   });

	** API IntersectionObserver 
		E' UN API CHE MI PERMETTE DI OSSERVARE UN ELEMENTO DEL DOM E DI INVOCARE UN CALLBACK QUANDO QUESTO ELEMENTO VIENE "INTERSECATO" DA UN ALTRO ELEMENTO, CHE PUO' ESSERE IL VIEWPORT. 
		QUANDO FACCIO SCROLL IN PRATICA MUOVO IL VIEWPORT ATTRAVERSO LA PAGINA E QUINDI IL VIEWPORT "INCONTRA" GLI ELEMENTI IN PAGINA. 
		L'INTERSECTIONOBSERVER RIESCE AD ACCORGERSI QUANDO IL VIEWPORT, MA NON SOLO QUESTO !, INCROCIA UN ELEMENTO IN PAGINA CHE GLI DICO DI OSSERVARE, E IN QUESTO CASO ESEGUE IL CALLBACK CHE GLI HO SPECIFICATO. 
		LA "PORZIONE" DI INCROCIO CHE FA SCATTARE IL CALLBACK E' DEFINITA DAL PARAMETRO *THRESHOLD, POSSO DEFINIRE UN ARRAY DI THRESHOLD. 
		IL CALLBACK DEVE AVERE DUE PARAMETRI: entries (I "SEGNALI" CHE MI GENERA L'OBSERVER, UNO PER OGNI THRESHOLD SPECIFICATO) E observer (L'OBSERVER STESSO, PARAMETRO NON OBBLIGATORIO)
			SE IMPOSTO THRESHOLD CON UN ARRAY DI VALORI, ENTRIES SARA' UN ARRAY, PRENDO COMUNQUE L'ELEMENTO CON INDICE 0
		
		NELL'ESEMPIO OSSERVO UNA SEZIONE DELLA PAGINA (SECTION1) E SPECIFICO DUE THRESHOLD: 0 E 0.2 (20%).
		IN QUESTO MODO QUANDO SCROLLO VERSO IL BASSO E SECTION1 INIZIA AD ENTRARE NEL VIEWPORT, QUANDO RAGGIUNGE IL 20% SCATTA IL CALLBACK. 
		QUANDO CONTINUO LO SCROLL VERSO IL BASSO E LA SEZIONE E' COMPLETAMENTE FUORI DAL VIEWPORT (THRESHOLD 0) ALLORA IL CALLBACK SCATTA DI NUOVO. 
			const callback = function (entries, observer) {
			  entries.forEach(entry => console.log(entry));
			}
			const opt = {
			  root: null,       //specifico l'elemento che andrà a intersecare l'elemento osservato. se null è il viewport !
			  threshold: [0, 0.2]    //percentuale (in decimi, 0.1=10%) di intersezione che farà eseguire il callback. posso passare anche un array. 
			}
			const observer = new IntersectionObserver(callback, opt);
			observer.observe(section1);			
			
		ALTRO ESEMPIO: NAVBAR DELL'HEADER CHE VOGLIO MOSTRARE QUANDO SCROLLO IN BASSO E AD UN CERTO PUNTO L'HEADER NON E' PIU' VISIBILE. 
			const header = document.querySelector('.header');	
			const navHeight = nav.getBoundingClientRect().height;   // ottengo altezza nav

			const stickyNav = function (entries) {
			  const entry = entries[0];	  // mi prendo la prima entry che è l'ultima generata 
			  // const [entry] = entries; //stessa cosa usando spread ma non si capisce..
			  if (!entry.isIntersecting) nav.classList.add('sticky');	//isIntersecting è true quando l'header non è più intersecato dal viewport, quindi quando non lo è più mostro la navbar, altrimento quando lo è non la mostro più
			  else nav.classList.remove('sticky');
			}
			const opt = {
			  root: null,       //specifico l'elemento che andrà a intersecare l'elemento osservato. se null è il viewport !
			  threshold: 0,    //percentuale (in decimi, 0.1=10%) di intersezione che farà eseguire il callback. posso passare anche un array. qui metto 0 perché voglio attivare quando l'header non è più visibile 
			  rootMargin: `-${navHeight}px` //margine del root, togliendo esattamente la dimensione del navbar faccio in modo che raggiunga threshold 0 90 pixel prima che finisca l'header.
			}
			const headerObserver = new IntersectionObserver(stickyNav, opt);
			headerObserver.observe(header);			
			
		ALTRO ESEMPIO, MOSTRARE DELLE SEZIONI IN PAGINA MAN MANO CHE SCROLLO VERSO IL BASSO. 
			const revealSection = function (entries, observer) {
			  const [entry] = entries;

			  if (!entry.isIntersecting) return;  // se l'entry non è di intersezione esco

			  entry.target.classList.remove('section--hidden'); //rimuovo il class hidden in modo da mostrare la sezione 
			  observer.unobserve(entry.target);  // una volta mostrata la sezione non mi serve più osservarla e quindi la tolgo dall'observer
			}
			const allSections = document.querySelectorAll('.section');

			const sectionObserver = new IntersectionObserver(revealSection, {
			  root: null,
			  threshold: 0.15
			});
			allSections.forEach(section => {			// ciclo su tutte le section per: aggiungerle all'observer e nasconderle (aggiungendo un class che imposta opacity: 0)
			  sectionObserver.observe(section);				
			  section.classList.add('section--hidden');
			});
		
	** IMAGE LAZY LOAD 
		<img 
			src="img/grow-lazy.jpg" 	// in src metto immagine a basso risoluzione
			data-src="img/grow.jpg" 	// in data-src metto immagine ad alta risoluzione che viene caricata in un secondo momento
			alt="Plant" 	
			class="features__img lazy-img" />	// lazy-img, style css che applica filter: blur(20px); all'immagine a bassa risoluzione 
			
		const imgTargets = document.querySelectorAll('img[data-src]');
		const loadImg = function (entries, observer) {
		  const [entry] = entries;

		  if (!entry.isIntersecting) return;  // se l'entry non è di intersezione esco

		  const img = entry.target;
		  img.src = img.dataset.src;		  // sostituisco src (che ha l'immagine SD) con quella HD nell'attributo data-src 
		  img.addEventListener('load', function (e) {
			img.classList.remove('lazy-img');	// tolgo il blur solo dopo che l'immagine è stata caricata !
		  });
		  observer.unobserve(img);	
		}
		const imgObserver = new IntersectionObserver(loadImg, {
		  root: null,
		  threshold: 0,
		  rootMargin: '200px'
		});
		imgTargets.forEach(img => imgObserver.observe(img));			
		
	** SLIDER COMPONENT 
const slider = function () {
  const btnLeft = document.querySelector('.slider__btn--left');
  const btnRight = document.querySelector('.slider__btn--right');
  const slides = document.querySelectorAll('.slide');
  const dotsContainer = document.querySelector('.dots');

  let curSlide = 0;
  const maxSlides = slides.length;

  // Functions
  const createDots = function () {
    slides.forEach((_, i) => dotsContainer.insertAdjacentHTML('beforeend', `<button class="dots__dot" data-slide="${i}"></button>`));
  }

  const activateDot = function (slide) {
    document.querySelectorAll('.dots__dot').forEach(e => e.classList.remove('dots__dot--active'));
    // select the dot having attribute data-slide equal to input slide
    document.querySelector(`.dots__dot[data-slide="${slide}"]`).classList.add('dots__dot--active');
  }

  // slides.forEach((slide, i) => slide.style.transform = `translateX(${100 * i}%)`);
  const goToSlide = function (slide) {
    slides.forEach((s, i) => s.style.transform = `translateX(${100 * (i - slide)}%)`);
  }

  const prevSlide = function (e) {
    curSlide--;
    if (curSlide < 0) curSlide = (maxSlides - 1);
    goToSlide(curSlide);
    activateDot(curSlide);
  }
  const nextSlide = function (e) {
    curSlide++;
    if (curSlide >= maxSlides) curSlide = 0;
    goToSlide(curSlide);
    activateDot(curSlide);
  }

  const init = function () {
    createDots();
    goToSlide(curSlide);
    activateDot(curSlide);
  }
  init();


  btnLeft.addEventListener('click', prevSlide);
  btnRight.addEventListener('click', nextSlide);

  document.addEventListener('keydown', function (e) {
    e.key === 'ArrowLeft' && prevSlide();
    e.key === 'ArrowRight' && nextSlide();
  });

  // Use event delegation by adding an event listener to the dots container instead of adding it to each dot
  dotsContainer.addEventListener('click', function (e) {
    const elem = e.target;
    if (!elem.classList.contains('dots__dot')) return;
    //activateDot(elem);
    const slide = elem.dataset.slide;
    goToSlide(slide);
    activateDot(slide);
  });
}
slider();

	*** LIFECYCLE DOM EVENTS 
		1. DOM CONTENT LOADED ("DOMContentLoaded")
			FIRED BY DOCUMENT QUANDO L'HTML E' STATO COMPLETAMENTE PARSATO (DOWNLOADED + CONVERTED IN DOM TREE) + TUTTI GLI SCRIPT SCARICATI ED ESEGUITI****. 
				**** MA NON IMMAGINI E ALTRE RISORSE ESTERNE COME CSS !! ****
				**** MA NON ASPETTA L'ESECUZIONE DEGLI SCRIPT JS CON ASYNC !! ****
				**** MA INVECE ASPETTA L'ESECUZIONE DEGLI SCRIPT JS CON DEFER !! 
				NOTA BENE: IL TEMPO DI ESECUZIONE DEL DOMCONTENTLOADED SI VEDE IN CHROME DEV TOOLS, NETWORK BARRA IN BASSO 
				NOTA BENE: CORRISPONDE A JQUERY DOCUMENT.READY !!!!!!
			document.addEventListener('DOMContentLoaded', function (e) {
			  console.log("ciao da giggi", e);
			})				
		2. LOAD EVENT ("load")
			FIRED BY WINDOW QUANDO ANCHE LE IMMAGINI E LE RISORSE ESTERNE, COME CSS, SONO STATE CARICATE, INSOMMA QUANDO LA PAGINA E' STATA CARICATA NELLA SUA INTEREZZA
				NOTA BENE: IL TEMPO DI ESECUZIONE DEL LOAD SI VEDE IN CHROME DEV TOOLS, NETWORK BARRA IN BASSO 
			window.addEventListener('load', function (e) {
			  console.log('window.load', e);
			})				
		3. BEFORE UNLOAD ("beforeunload")
			FIRED BY WINDOW IMMEDIATELY BEFORE A USER IS ABOUT TO LEAVING A PAGE. 
				NOTA BENE: IN ALCUNI BROWSER, MA NON IN CHROME BISOGNA AGGIUNGERE e.preventDefault() NELLA FUNCTION DELL EVENT LISTENER 
window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  console.log('window.beforeunload', e);
  e.returnValue = '';		// in chiusura tab o browser O RELOAD DELLA PAGINA! fa uscire il popup che chiede conferma !
})				
		
	*** DEFER E ASYNC PER CARICAMENTO FILE JS 
	
		** TAG SCRIPT NELL'HEAD: 
			QUANDO IL BROWSER HA SCARICATO L'HTML INIZIA FARE IL PARSE PER CONVERTIRLO IN DOM TREE.
			SE UN TAG SCRIPT E' STATO POSIZIONATO NELL'HEAD, IL BROWSER METTE IN PAUSA IL PARSING, SCARICA IL JS E LO ESEGUE. 
			QUANDO E' TERMINATA L'ESECUZIONE IL BROWSER PROSEGUE IL PARSING E QUANDO HA TERMINATO FA IL FIRE DELL'EVENTO DOMContentLoaded. 
			
			NON VA BENE PERCHE': 
				- IL PARSING DELL'HTML VIENE INTERROTTO 
				- L'ESECUZIONE DEL JS AVVIENE A DOM TREE NON ANCORA COMPLETATO 
		
		** TAG SCRIPT ALLA FINE DEL BODY: 
			IL BROWSER RIESCE A FARE IL PARSING DELL'HTML FINO ALLA FINE DEL BODY. 
			TROVA IL TAG SCRIPT SCARICA IL JS E LO ESEGUE.
			
			MOLTO MEGLIO PERCHE': 
				- IL PARSING DELL'HTML NON VIENE INTERROTTO, ANCHE SE POTREBBE ESSERLO SE IL TAG SCRIPT NON E' DAVVERO L'ULTIMO ELEMENTO DEL BODY 
				- L'ESECUZIONE DEL JS AVVIENE A DOM TREE COMPLETATO, QUINDI IL JS TROVA TUTTI GLI ELEMENTI DELLA PAGINA PRESENTI NEL DOM
				- SOLUZIONE NON ANCORA OTTIMALE
				
		** TAG SCRIPT NELL'HEAD CON PARAMETRO ASYNC 
			IL DOWNLOAD DEL JS AVVIENE DURANTE DELL'HTML, IN MODO ASINCRONO, IN QUESTO MODO QUANDO IL BROWSER TROVA IL TAG SCRIPT E' GIA' PRONTO PER ESEGUIRLO 
			MA QUANDO INIZIA L'ESECUZIONE IL PARSING DELL'HTML VIENE COMUNQUE INTERROTTO 
			
		** TAG SCRIPT NELL'HEAD CON PARAMETRO DEFER 
			DOWNLOAD DEL JS ESEGUITO IN MODO ASINCRONO, DURANTE L'INIZIO DEL PARSING DELL'HTML (COME CON ASYNC) 
			ESECUZIONE DEL JS *SOLO DOPO* CHE IL PARSING DELL'HTML E' TERMINATO, QUINDI IL PARSING DELL'HTML NON VIENE MAI INTERROTTO ! 
			
			
		** CONFRONTO TRA SCRIPT IN END BODY, ASYNC E DEFER 
			* END BODY: 
				. LO SCRIPT E' SCARICATO ED ESEGUITO DOPO CHE IL PARSING DELL'HTML E' TERMINATO 
				
			* ASYNC IN HEAD 
				. LO SCRIPT E' SCARICATO IN MODO ASINCRONO ED ESEGUITO IMMEDIATAMENTE 
				. RICORDIAMO CHE L'EVENTO DOMContentLoaded (DOCUMENT READY) VIENE TRIGGERATO QUANDO SONO STATI ESEGUITI TUTTI GLI SCRIPT MA NON QUELLI CON ASYNC ! 
					DOMContentLoaded NON ASPETTA GLI SCRIPT ASYNC !
				. L'ORDINE DI ESECUZIONE DEGLI JS CON ASYNC NON E' GARANTITO CHE SIA L'ORDINE DEI TAG SCRIPT, QUELLO SCARICATO PRIMA VIENE ESEGUITO PRIMA 
				
			* DEFER IN HEAD 
				. LO SCRIPT E' SCARICATO IN MODO ASINCRONO ED ESEGUITO SOLO DOPO LA FINE DEL PARSING DELL'HTML (COME AVVIENE CON QUELLI REGOLARI ALLA FINE DEL BODY)
				. L'EVENTO DOMContentLoaded ASPETTA GLI SCRIPT CON DEFER (COME FA PER QUELLI REGOLARI ALLA FINE DEL BODY)
				. L'ORDINE DI ESECUZIONE E' QUELLO DEI TAG, QUINDI SE IL MIO JS DIPENDE DA UN JS DI TERZE PARTI, QUESTO DEVE ESSERE DICHIARATO PRIMA 
				
		** USE CASES PER ASYNC E DEFER (IN HEAD) 
			* USARE *DEFER* PER MIEI JS, SPECIE QUANDO DIPENDONO DA ALTRI JS: ENTRAMBI SARANNO DICHIARATI CON DEFER E LA LIBRERIA DA CUI DIPENDO DEVE ESSERE DICHIARATA PRIMA DELLA MIA 
			* USARE *ASYNC* PER JS DI TERZE PARTI O LIBRERIE SINGOLE CHE NON DIPENDONO DA NESSUN'ALTRA  
			* USARE JS IN END BODY QUANDO SO CHE VENGONO USATI VECCHI BROWSER CHE NON SUPPORTANO HTML 5 
			
	** OOP IN JS 		
		>>>>FUNCTIONAL PROGRAMMING E' UN ALTRO PARADIGMA DI PROGRAMMAZIONE CHE AFFIANCA OOP PROGRAMMING. 
		
		PROTOTYPES: CONTIENE PROPERTIES E METHODS CHE GLI OGGETTI AD ESSO COLLEGATI POSSONO ACCEDERE ED USARE (PROTOTYPAL INHERITANCE) 
		OBJECTS ARE LINKED TO A PROTOTYPE OBJECT 
		OBJECTS DELEGATE THEIR BEHAVIOUR (=METHODS) TO THEIR PROTOTYPE (MENTRE IN OOP CLASSICO I METODI VENGONO COPIATI DALLA CLASSE ALL'ISTANZA, QUI INVECE I METODI RIMANGONO DEFINITI NEL PROTOTYPE E GLI OGGETTI ISTANZIATI DELEGANO I LORO METODI AL CODICE CONTENUTO NEL PROTOTYPE
		IL PROTOTYPE E' ACCESSIBILE CON Oggetto.prototype PER ESEMPIO Array.prototype  
		
		** TRE MODI PER FARE OOP IN JS
			1. CONSTRUCTOR FUNCTIONS 
				- TECNICA PER CREARE OGGETTI DA FUNCTIONS
				- E' IL MODO CON CUI FUNZIONANO OGGETTI COME Array, Map, Set 
				- E' IL MODO PER FARE OOP CHE ESISTE DALLE PRIME VERSIONI DI JS 
			
			2. ES6 CLASSES, SONO UN "SYNTACTIC SUGAR" DEL METODO UNO. NON CORRISPONDONO AL CONCETTO DI CLASSE STANDARD OOP !
				- E' UN MODO PIU' FIGO PER USARE IL METODO UNO 
			
			3. Object.create()
				- E' IL MODO PIU' SEMPLICE PER LINKARE UN OGGETTO AL SUO PROTOTYPE OBJECT MA NON E' QUELLO PIU' USATO..
				
		
		** CONSTRUCTOR FUNCTIONS (COSTRUTTORE!)
			SONO FUNCTION NORMALI CHE SI INVOCANO CON new 
			INIZIANO CON LETTERA MAIUSCOLA 
				const Nomefunction = function(parametri costruttore) {
					// instance properties 
					this.parametro1 = parametro1; 	// this.parametro non deve essere uguale a parametro ricevuto nel costrutture ma è una convention 
					this.parametro2 = parametro2; 
					ecc.. 
				}
			INVOCO CON new 
				new Nomefunction(parametri costruttore) 
				
				QUESTO FA SUCCEDERE 4 COSE DIETRO LE QUINTE: 
				1. VIENE CREATO UN EMPTY OBJECT {}
				2. LA FUNCTION VIENE CHIAMATA E IL THIS VIENE IMPOSTATA CON L'OGGETTO VUOTO 
				3. L'OGGETTO CREATO VIENE LINKATO AL PROTOTYPE 
				4. LA FUNCTION RITORNA AUTOMATICAMENTE L'OGGETTO, NON C'E' BISOGNO DI FARE RETURN 
			
			TESTO CON instanceof 
				const giggi = new Person("Pierluigi", 1974);
				console.log(giggi instanceof Person);				
				
			CONSTRUCTOR FUNCTION prototype   SAREBBE IL CLASS, MI PERMETTE DI DEFINIRE METODI CHE POI SONO MESSI A DISPOSIZIONE ALLE ISTANZE QUANDO LE CREO CON new 
				E' UN OGGETTO, A SUA VOLTA HA UN __proto__ CHE LO CONNETTE A Object.prototype 
		
			** DEFINIRE METODI NEL prototype 
				Nomefunction.prototype.nomeFunction = function(){
					...
				}
					NOTA BENE: I METODI **NON** SI DICHIARANO NEL CONSTRUCTOR FUNCTION, BENSI' NEL PROTOTYPE !!!
						IN QUESTO MODO ESISTE UNA SOLA COPIA DEL METODO, NEL PROTOTYPE. 
						SE LA DICHIARO INVECE NEL CONSTRUCTOR FUNCTION E POI LO ISTANZIO, AVREI UNA COPIA DEL METODO IN OGNI ISTANZA CREATA COL new 
						
				OGNI ISTANZA PUO' ACCEDERE AL PROPRIO PROTOTYPE CON LA PROPERTY __proto__ CHE CORRISPONDE AL ConstructorFunction.prototype
				TEST: Nomefunction.prototype.isPrototypeOf(istanza) 
				
					ATTENZIONE !!! Nomefunction.prototype NON E' IL PROTOTYPE DI Nomefunction MA DEGLI OGGETTI CHE VENGONO INSTANZIATI CON new !! 
					
			** DEFINIRE PROPERTY NEL prototype
				Nomefunction.prototype.nomeProperty = valore; 
				
				TUTTE LE ISTANZE EREDITANO LE PROPERTY DEFINITE IN QUESTO MODO. 
				QUESTE PROPERTY SONO EREDITATE MA NON SONO PROPRIE DELL'OGGETTO, BENSI' DEL PROTOTYPE: SOLO QUELLE DEFINITE NEL COSTRUTTORE LO SONO. 
				PER FARE CHECK SE PROPERTY E' DELL'OGGETTO: istanza.hasOwnProperty('nomeproperty') 
			
			** PROTOTYPE CHAIN 
				IN PRATICA QUANDO INVOCO UN METODO O REFERENZIO UNA PROPERTY SU UN OGGETTO, JS PER PRIMA COSA GUARDA SE ESISTONO NELL'OGGETTO. 
				SE NON ESISTONO, GUARDA SE C'E' __proto__ E SE LO TROVA, VUOL DIRE CHE L'OGGETTO E' LINKATO A UN PROTOTYPE, PER CUI RISALE AL PROTOTYPE E CONTROLLA SE LI' C'E' IL METODO O LA PROPERTY.
				L'OGGETTO prototype A CUI E' LINKATA LA MIA ISTANZA E' A SUA VOLTA UN OGGETTO CON LA PROPERTY __proto__ CHE LA LINKA A Object.prototype CHE E' IL TOP DELLA GERARCHIA DI PROTOTYPE. 
				LA PROPERTY Object.prototype.__proto__ E' INFATTI NULL. 
				
				Nomefunction.prototype.constructor = RESTITUISCE Constructor function !
				
			** ESTENDERE PROTOTYPE BUILD-IN DI JS 
				TUTTI GLI OGGETTI BUILT-IN DI JS HANNO IL PROTOTYPE PER ESEMPIO Array.prototype. NE CONSEGUE CHE POSSO AGGIUNGERE METODI E PROPRIETA' A QUESTI OGGETTI E AUTOMATICAMENTE TUTTE LE ISTANZE IN ESECUZIONE LI EREDITERANNO. 
				
		**  ES6 CLASSES
		
			SONO COME LE FUNCTION, POSSO DICHIARARLE CON UN ESPRESSIONE O UNA DICHIARAZIONE. 
			DI FATTO LE CLASS SONO UN TIPO SPECIALE DI FUNCTION, SOTTO IL COFANO CI SONO LE FUNCTION. 
			
			** CLASS EXPRESSION
				const PersonCl = class {
				}
				
			** CLASS DECLARATION 
				class PersonCl {
					constructor(firstName, birthYear) {
						this.firstName = firstName;
						this.birthYear = birthYear;
					}
					//methods aggiunti al prototype degli object creati con new 
					calcAge = function(){
						console.log(2032-this.birthYear);
					}
					// niente virgole !!
					greet = function(){
						console.log(`welcome ${this.firstName}`);
					}	
				}

				const pippo = new PersonCl('Giggi', 1974);
				console.dir(pippo);
				
				//posso sempre aggiungere metodi o property agendo sulla property prototype 
				PersonCl.prototype.welcome = function(){
					..
				}
				
			** NOTA BENE 
				* CLASS NON SONO HOISTED, CIOE' PRIMA LE DEVO DICHIARARE E POI LE POSSO USARE, NON VICEVERSA !
				* CLASS SONO FIRST-CLASS CITIZENS, COME LE FUNCTION, CIOE' LE POSSO PASSARE COME PARAMETRO IN INPUT E OUTPUT 
				* CLASS SONO ESEGUITE IN STRICT MODE 
				
		** GETTER AND SETTER (ACCESSOR PROPERTIES) 
			IN JS TUTTI GLI OGGETTI HANNO GETTER E SETTER. SI CHIAMANO ACCESSOR PROPERTIES (MENTRE GLI ALTRI SONO DATA PROPERTIES). 
			* GETTER: PER DICHIARARE METTERE get PRIMA DEL METODO: 
			
			