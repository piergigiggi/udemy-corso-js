
chrome 
ctrl-shift-j console chrome
ctrl-shift-i elements
ctrl-shift-m modo mobile on/off
console chrome: posso usarla come calcolatrice !!

vscode
ctrl+ù toggle comments 
IN HTML: ! + TAB  SCRIVE TEMPLATE HTML DI BASE 

windows
win+è emoticons

ROBA UTILE DA INSTALLARE IN VSCODE 
	LIVE SERVER
	
PAROLE UTILI PER SPIEGARE
	ELEMENTS HTML, NO TAG, I TAG SONO I DELIMITATORI, UN ELEMENTO INPUT, UN ELEMENTO SELECT ECC..
	
BEST PRACTICES 
	HTML
		NON USARE ID PER SELEZIONARE O APPLICARE STYLE A ELEMENTI, USARE INVECE CLASS !!
		ID E CLASS SI SCRIVONO CON -, NON IN CAMELCASE, ESEMPI: course-image, your-name 
	JS 
		. NON USARE VAR, USARE CONST/LET 
		. NON USARE ARROW FUNCTION COME METODI DI UN OGGETTO, IL THIS IN ESSE NON PUNTA ALL'OGGETTO MA AL PRIMO SCOPE PARENT UTILE 
		. USARE ARROW FUNCTION DENTRO UNA FUNCTION IN UN METODO PER POTER USARE IL THIS CHE PUNTA ALL'OGGETTO, ALTRIMENTI DEVO USARE IL TRUCCO DEL SELF/THAT PRIMA DELLA FUNCTION DENTRO IL METODO 
		. USARE STRICT MODE !
		. USARE === !== 
		. ATTENZIONE A Object.assign PER FARE COPIA DI OGGETTI: ESEGUE SHALLOW COPY CIOE' COPIA DI PRIMO LIVELLO, PER FARE DEEP CLONE USARE... DA COMPLETARE 
		. USARE CONST CON GLI OGGETTI PER EVITARE (GRAZIE AD ERRORE) CHE VENGANO SOSTITUITI DA ALTRI OGGETTI, ANCHE DA OGGETTO VUOTO
		. GLI ARRAY SONO OGGETTI: ATTENZIONE ! POSSO DEFINIRLI CON CONST E VARIARNE IL CONTENUTO MA NON SOSTITUIRLO CON UN ALTRO ARRAY, PER FARE CIO' DEVO DEFINIRLI CON LET 
		. USARE IL DESTRUCTURING SE HO BISOGNO DI SCAMBIARE IL VALORE DI DUE O PIU' VARIABILI, ANCHE SE NON SONO ARRAY ! 
			let a = "ciao";
			let b = "pippo";
			let [a,b] = [b,a]  // HO SCAMBIATO TRA LORO LE VARIABILI a E b 
		. USARE IL DESTRUCTURING PER RICEVERE PIU' VALORI DA UNA FUNCTION E ASSEGNARLI AD ALTRETTANTE VARIABILI (AL POSTO DI RESTITUIRE UN OGGETTO..)
			NELLA FUNCTION: 
				return [valore1, valore2, ecc..]	// return restituisce array 
			NELL'INVOCAZIONE: 
				const [valore1, valore2, ecc..] = function(..); 	// l'array restituito viene destrutturato in variabili 
		. SI PUO' FARE ANCHE DESTRUCTURING IN UN DESTRUCTURING, SE L'ARRAY IN INPUT HA A SUA VOLTA DEGLI ARRAY 
				const listaNum = [1, 2, [3, 4]];
				const [uno, , [tre, quattro]] = listaNum;
				console.log(uno, tre, quattro);   // SALTO IL DUE E ESTRAGGO TRE E QUATTRO CHE STANNO IN UN ARRAY NELL'ARRAY		
		. USARE DESTRUCTURING DI OGGETTO AL POSTO DI LISTA DI ARGOMENTI IN UNA FUNCTION QUANDO NE HA PARECCHI 
		. USARE SPREAD OPERATOR PER FARE COPIE DI OGGETTI E ANCHE AGGIUNGERE PROPERTY 

NOTA BENE: IN GULP IL CHECK DELLA VERSIONE VIENE FATTO DA BABEL, CON FALLBACK PER GESTIRE CODICE IN VECCHI BROWSER. APPROFONDIRE. 

variabili
	caratteri ammessi: _ $
	non possono iniziare con numeri 
	"name" si può ancora usare ma può dare problemi 
	scrivere le costanti tutto in maiuscolo 
	
data types, sono 7 
	number: sono tutti floating, cioè hanno i decimali ! anche quando definisco un "intero" let age = 23 in realtà per js è 23.0
	string
	boolean 
	undefined: valore assunto da una variabile che non è stata ancora defined (empty value). es: let age; ma è anche il tipo di "dato" di una variabile non valorizzata. 
				quindi se dichiaro una variabile senza valore, il suo valore sarà undefined e il suo tipo (typeof) sarà undefined 
				infatti typeof undefined (il valore) restituisce undefined (il tipo) 
				attenzione che typeof restisce il tipo in una stringa ! quindi se faccio typeof typeof undefined ottengo string perché il tipo di dato del risultato di typeof undefined è "undefined" che è una stringa :)
	null: empty value, come undefined.. 
		stranezza: typeof null restituisce "object" ! e' un bug di una vecchia versione di JS mantenuto per legacy
	Symbol (introdotto con ES2015) value unico e che non può essere modificato ? 
	BigInt (introdotto con ES2020) per numeri troppo grandi per number 
	
	NB: è il valore che è di un tipo, non la variabile!. le variabili non devono essere manualmente definite di un tipo, lo fa dinamicamente JS in base al valore immesso nella variabili (Dynamic Typing). 
		da qui deriva la possibilità di valorizzare una variabile con valori di tipo diverso, per esempio prima numero e poi stringa.
		proprio per questo esiste l'operatore typeof che mi dice di che tipo è un valore o una variabile valorizzata
		per esempio typeof true restituisce boolean 
		
	cambiare valore ad una variabile si dice mutating the variable 

commenti 
	vs code: 
	
dichiarare variabili: 
	let usare per variabili che cambieranno valore 
	var è come let, non usare, roba vecchia e poi è scope global
	const dichiarare una costante, il cui valore non può essere mutato (immutable variable); non possono essere dichiarate senza valore, è illegal
		const ageOfBirth = 1991; 
		BEST PRATICE: usare const come prima scelta, e let solo se ho bisogno di cambiare valore in seguito. mutable variables aumentano la probabilità di bug nel codice. 
		NOTA BENE: solo i dati primitivi sono immutable, gli oggetti invece sì ! anche con const !
		
	Posso dichiarare più variabili nella stessa riga di codice: 
		const x, y; 
	Posso assegnare più variabili nella stessa riga: 
		x = y = 20-10;
	
console.log può scrivere n variabili, basta separarle con una virgola, esempio: console.log(variabile1, variabile2, variabile3), vengono separati da uno spazio
	console.log("variabile1: " + variabile1, "variabile2: " + variabile2);
	
operatori matematici 
	+ (anche per concatenare)
	-
	* 
	/ 
	** potenza 2 ** 3 = 2 elevato alla potenza di 3 
	
typeof operator 
assign operator 
	= 
	+= 	variabile = variabile + ...
	*= /=
	++  aggiunge 1 
	-- toglie 1 
comparison operator 
	< > <= >=  attenzione all'ultima, non scrivere => perché è lambda !
	
operator precedence 
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_precedence
		tabella precedence numbers !
		
Template literals multiline strings 
	Introdotto in ES6 2015 
	usa ` (alt 96) per dichiarare inizio fine template e all'interno ${variabile o espressione} per inserire variabile o un'espressione js come operazione matematica o altro ancora 	
	const log = `var1: ${var1}, var2: ${var2}`
	***** NOTA BENE: il carattere backtick ` si può usare anche delimitatore di stringa, ha il vantaggio di poter usare al suo interno apice singolo o doppio senza problemi WOW !
	inoltre si può andare a capo senza usare backslash e altra roba simile: 
		console.log(`Ciao 
		da
		giggi`);
	
Type Conversion = Manual convertion 
	Number(string) converte stringa in number, se in input c'è qualcosa di diverso da numero restituisce NaN (Not a Number) (typeof NaN restituisce "number" !)
	String(numero) converte number in string 
Type Coercion   = Automatic convertion per esempio quando concateno con l'operatore + stringa con numero, JS converte number in string in automatico.
				 Attenzione: gli operatori matematici -,*,/ fanno il contrario, convertono stringhe in numeri. esempio '23' - '10' risultato 13. 
				 
Truthy e Falsy values: E' IL CONCETTO CHE FA FUNZIONARE L'IF(VARIABILE) !!
	falsy = sono valori che non sono esattamente falsi ma lo diventano quando li converto in boolean. Sono 5: 0, '', undefined, null, NaN 
		Esempio: Boolean(0) restituisce false
	truthy = sono tutti gli altri valori, cioè tutti i numeri non zero e le stringhe non vuote e gli oggetti anche vuoti ({})
		Boolean({}) true (empty object) 
	NOTA: non serve convertire con Boolean perché JS applica Coercion e lo fa implicitamente. 
	
Equality Operators 
	=== strict equality operator, confronta senza fare prima type coercion cioè senza fare auto conversion 	USARE QUESTO !!!! EVITA BUG 
		!== diverso da 
	==  loose equality operator, esegue auto convertion prima di fare confronto 
		!= diverso da 
		18 === 18 true 
		18 === '18' false 
		18 == '18' true  (converte prima la stringa in numero e poi confronta) 
	
Prompt 
	input utente, restituisce stringa 
	Esempio: const numero = prompt("inserisci numero"); 
	
if 
	if (..) {
	} else if {
	} else {
	}

Logic operators 
	&& and 
	|| or
	! not 
	
switch..case..default statement 
	switch (variabile) {
		case 'stringa': 
			...
			break;
		case 'stringa': 
			...
			break;
		case 'aaa':
		case 'bbb':
			... (codice sia per aaa che per bbb)
			break;
		default:
			...
	}

Conditional Operator (Ternary, perchè ha tre parti!), è un operator quindi restituisce un valore   
	condizione ? statement per true : (obbligatorio)statement per false;
	const variabile = condizione ? statement per true : (obbligatorio)statement per false;
	si può usare in un Template literals dentro ${...} perchè restituisce valore, a differenza dell'if-then che è uno statement, non restituisce valore e quindi non si può usare dentro  ${...}
	
espressione = restituisce valore 
statement = istruzione

***** FOUNDAMENTALS PART 2 

'use strict';
	prima istruzione di un file js, altrimenti non strict mode non viene attivato
	ci impedisce di fare determinate cose
	crea errori visibili in console quando invece js non in strict mode va in errore in modo silente senza scrivere nulla in console 
		esempi: 
			- quando uso variabile non dichiarata perché ho scritto un typo 
			- quando uso parole chiavi riservate, di uso futuro. tipo interface, private 

** Functions	
	function declaration: usare key word "function" per dichiarare funzione, è possibile invocare la function prima del suo declaration 
		paramentro: dichiarazione della variabile in input nella function 
		argomento : valore passato alla function quando la si invoca, finisce nel parametro 
		formato: 
			function nome(parametri) {
				...
			}
	function expression: dichiaro variabile che valorizzo con una function, non è possibile invocare la function prima della dichiarazione della variabile che la "contiene" 
			const variabile = function (parametri) {  // variabile diventa il nome della function 
				...
			}
			consto var = variable(parametri); 
			NOTA BENE questo formato è possibile perchè la function diventa un'espressione, che può anche restituire un valore 
				Da qui il concetto IMPORTANTE che una function è un value, un valore ! sarà del tipo del dato restituito dal return oppure undefined se la function non restituisce niente 
				
	(ES6) arrow function, una forma abbreviata di function expression, return è implicito se ho un'unica istruzione, altrimenti lo devo scrivere 
			const variable = (parametri) => { // se c'è un unico parametro posso omettere parentesi tonde, se c'è un'unica istruzione posso omettere parentesi graffe e "return" 
				istruzione;
				return ..;
			}
			
** Data structures 
	Arrays (zero-based)
		usare parentesi quadre ('literal syntax')
			const friends = ['Mario', 'Giggi', 'Luca'];
			const friends = ['Mario', 123, 'Luca'];
		usare new Array 
			const anni = new Array(1990, 1995, 2000, 2005, 2023, 'pippo');		// notare che l'array non è tipizzato, può contenere valori di tipo diverso 
			
		accedere: usare sempre parentesi quadre e indice che parte da zero; tra le parentesi posso usare un'espressione che restituisce l'indice voluto
			const amico = friends[0]; // ritorna 'Mario'
			const ultimo = friends[friends.length -1] // ottengo l'ultimo elemento: numero elementi - 1 
			
		n.ro elementi: length 
			
		modificare elemento: 
			friends[2] = 'Pippo';
			NOTA BENE: posso mutare singolo elementi dell'array anche se ho dichiarato l'array con const. Questo perchè solo i tipi di dato primitivi sono immutable mentre gli oggetti, tra i qualli anche Array, sono mutable, anche se dichiarati con const
					   non posso invece sostituire l'array con un altro array ! se lo faccio ricevo errore di oggetto immutable
		
		array dentro array: SI-PUO'-FAREE ! 
			const gianni = ['Gianni', 'Rossi', 2023-1974, [10,20,30]];
			
		array di funzioni: SI-PUO' FARE ! 
			const anni = [calcAge(years[0]), calcAge(years[1]), calcAge(years[years.length-1])];
			
		array operations (methods) 
			push 		aggiunge elementi alla fine dell'array, restituisce nuova lunghezza array
			unshift		aggiunge elementi all'inizio dell'array, restituisce nuova lunghezza array
			pop			elimina l'ultimo elemento dell'array, restituisce l'elemento rimosso
			shift		elimina il primo elemento dell'array, restituisce l'elemento rimosso
			indexOf		restituisce posizione dell'elemento in input, se l'elemento non esiste restituisce -1
			includes(ES6) restituisce true se l'elemento in input esiste nell'array, false se non esiste (testa con strict equality, vuol dire che se l'array ha un number e passo in input la stringa del number, includes non lo trova) 
			concat      concatena l'array con quello/i passato in input 
		
	Objects
		const oggetto = {
			property: valore,
			property: valore, 
			... 
			property: valore
		};
		valore puo' essere un primitivo, un'espressione, una function, un array, un altro oggetto, ecc.. 
		due modi per riferirsci alle property: 
			oggetto.property	// dot notation
			oggetto["property"] // bracket notation: posso comporre la stringa come voglio, con una variabile, una function ecc.. 
		aggiungere properties: 	// non serve dichiararle in anticipo nell'oggetto, come in java. si possono aggiungere dopo, quando l'oggetto è stato inizializzato
			oggetto.property = valore
			oggetto["property"] = valore 
		definire methods: 
			const oggetto = {
				property: valore, 
				...
				metodo: function(){
					return..
				},
				metodo2: (a,b) => a+b,
				metodo3: () => console.log(this.property) 	// nei metodi, con this posso riferirmi all'oggetto da cui ho invocato il metodo e accedere alle sue properties. 
															   ATTENZIONE CHE NELLE ARROW FUNCTIONS this SI COMPORTA IN MODO DIVERSO !!!!
			}
			
			oggetto.metodo2('aaa','bbb');
			oggetto['metodo2']('ccc','ddd');	//chiamo metodo anche con notazione bracket 
			
** Loops
	for(let indice=1; indice <= 10; indice++){		// finchè la condizione è vera il codice del for viene eseguito in loop
		istruzioni..
		if(...) continue;  // se vero continue salta al loop successivo
	}
	
	while(condizione){
	
	}
	
			
	let indice = ..;
	while(condizione) {			//continua a ripetere fintanto che la condizione è vera
		istruzioni
		istruzioni
		incremento indice
	}
		
	
** METODO DI APPROCCIO ALLA RISOLUZIONE DEI PROBLEMI 
	1. Understand the problem.
		questions..
	2. Breaking-up into sub problems 
	
	METODI CONSOLE 
		console.log
		console.warn
		console.error;
		console.table (ottimo per oggetti) 
		debugger
		
** HTML CSS ROBA CHE NON SO 
	HTML 
		in input attributo placeholder 
	CSS
		SELECTOR selettore, quelli più semplici sono quelli per cui si scrive il tag per selezionare il rispettivo elemento, per esempio body {...} h1{..}
		PER IMPORTARE: <link href="style.css" rel="stylesheet"/>
		SELECTOR PER CLASS INIZIA CON PUNTO 
		SELECTOR PER ID INIZIA CON #
		
	** BOX MODEL 
		OGNI ELEMENTO IN PAGINA PUO ESSERE INTESO COME UN BOX, UN RETTANGOLO, CON LE SEGUENTI PROPRIETA': 
			- CONTENT 
			- WIDTH: LARGHEZZA
			- HEIGHT: ALTEZZA
			- PADDING: AREA TRASPARENTE ATTORNO AL CONTENT, INSIDE THE BOX. USABILE PER CREARE SPAZIO ALL'INTERNO DEL BOX. PROPERTY padding
			- BORDER: ATTORNO AL PADDING E AL CONTENT 
			- MARGIN: AREA AL DI FUORI DEL BOX, DI FATTO TRA I BOX DI CIASCUN ELEMENTO: SPAZIO TRA I BOX 
			- FILL AREA: AREA CHE VIENE RIEMPITA DA BACKGROUND COLOR E BACKGROUND IMAGE, COMPRENDE CONTENT+PADDING+BORDER MA NON MARGIN !
			

	** ROBA UTILE DA INSTALLARE IN VS CODE 
		PRETTIER 
			poi andare in setting, cercare default formatter, selezionare esbenp.prettier-vscode
				selezionare anche format on save, mettere la spunta su Editor: Format On Save
		SNIPPET, PER EVITARE DI SCRIVERE console.log O ALTRA ROBA RIPETITIVA 
			setting, use snippet, use new global snippet file, dare nome del cavolo, uncomment l'esempio print to console 
			
		LIVE SERVER : PER AUTOMATIZZARE RELOAD BROWSER DOPO MODIFICA A JS 
			aggiunge pulsante GoLive in basso a destra
			per lanciarlo: aprire terminale e nel folder del progetto digitare live-server
			
	** codewars.com challenges for free 
	
	********* CSS **********
	
	inline elements: occupano spazio in una riga, non box, tipo tag anchor, input, button
	block elements : il loro spazio un box che occupa tutta la larghezza dello schermo
	
	commenti: /* .... */
	
	Global Reset: reimpostare tutti i margin e i padding 
		Per selezionare tutti gli elementi usare il selettore * 
	
	* {
		margin: 0;		// quando si imposta zero non serve specificare px o %
		padding: 0;
		box-sizing: border-box; //serve per dichiarare che voglio le dimensioni di un elemento esattamente come le ho dichiarate: se dichiaro una form con width 400 e padding 25 e margin 5, il width non sarà 400+25+25+5 ma la somma di tutto dovrà fare 400 
	}
	
	elemento1, elemento2 {  //stile per più elementi
		...
		...
	}
	
	** child selector: per selezionare un elemento contenuto in un altro elemento scrivo l'elemento che contiene e poi l'elemento contenuto separati da spazio 
	#mio-div h2 {		// seleziono elemento h2 contenuto nell'elemento con id mio-div
	
	}
	
	********** JAVASCRIPT DOM MANIPULATION ***********
	
	document.querySelector('selettore') // esempio .classe #div ecc..
		NOTA se selettore seleziona più elementi, restituisce solo il primo. per avere l'array di tutti gli elementi usare querySelectorAll
		non seleziona come jquery, seleziona proprio l'html dell'elemento selezionato 
		.textContent 	restituisce testo dell'elemento selezionato, per esempio per gli elementi p
		.value			restituisce valore di un elemento, per esempio input text 
	
	document.querySelectorAll('selettore') // esempio .classe #div ecc..  seleziona TUTTI gli elementi selezionati dal selettore in input 
		
	DOM = Document Object Manipulation, il browser crea una rappresentazione ad albero di tutti gli elementi dell'html 
		essendo un albero sono validi tutti i concetti tipici: child element, parent element, sibling element (fratello) ecc.. 
		per esempio un elemento P contenente un testo e un anchor, sarà un elemento con due child: text e a, il primo valorizzato col testo, il secondo con un child text per il suo testo 
		document è l'oggetto entry point del DOM 
		DOM non fa parte di Javascript ma fa parte del WEB APIs, implementate in ciascun browser e con le quali Javascript si interfaccia 
		
	Event Listener = codice eseguito al verificarsi di un evento ad uno specifico elemento 
		selezionare elemento, per esempio un button, e poi addEventListener 
		document.querySelector('.check').addEventListener(evento, funzione);
		
		document.querySelector('body').style.backgroundColor = '#60b347' 		// seleziono body element e imposto css style background-color che in javascript si scrive in Camel Case quindi backgroundColor  
																				// gli style si impostano sempre con una stringa ! no numeri
																				
		document.getElementById('id')	// get per id, non serve cancelletto !
																				
	elementoselezionato.classList	// restituisce elenco di classi dell'elemento 
		classList.remove('hidden','','') // rimuovo uno o più classi dall'elemento, non mettere il punto davanti !
		classList.add 
		classList.contains('hidden')     // 
		classList.toggle('class')   	 // se c'è il class lo toglie, altrimenti lo aggiunge 
		
	elementoselezionato.src = url 	// imposto l'attributo src a un elemento che lo supporta come img 
		
	Global events: sono quelli della tastiera, legati al document, quindi l'addEventListener in questo caso lo si fa su document 
		tre eventi intercettabili: 
			keyup		
			keypress
			keydown
		document.addEventListener('keydown', function(e){
			// nell'oggetto e che riceviamo in input ci sono tutte le info sull'evento catturato
			
		});
		
		
		
	*********** COME FUNZIONA JAVASCRIPT  ***************
	
	* MULTI-PARADIGM: 
		. PROCEDURAL PROGRAMMING 
		. OBJECT-ORIENTED PROGRAMMING
		. FUNCTIONAL PROGRAMMING
	  E: 
		. IMPERATIVE 
		. DECLARATIVE 
	
	* PROTOTYPE: E' LA CLASSE !! CREO IL PROTOTYPE CON TUTTI I METODI E POI QUANDO LO USO, L'OGGETTO CREATO EREDITA TUTTI I METODI 
	
	* FIRST-CLASS FUNCTIONS: QUANDO LE FUNCTIONS SONO GESTITE COME VARIABILI, POSSO PASSARE UNA FUNCTION COME PARAMETRO AD UN'ALTRA FUNCTION E UNA FUNCTION PUO' RESTITUIRE COME RISULTATO UNA FUNCTION 
	
	* DYNAMIC: LE VARIABILI NON SONO TIPIZZATE, LO SONO I VALORI ASSEGNATI ALLE VARIABILI. QUANDO ASSEGNO VALORI DIVERSI AD UNA VARIABILE, IL DATA TYPE DELLA VARIABILE VIENE CAMBIATO AUTOMATICAMENTE
		ESISTE TYPESCRIPT: UNA VERSIONE DI JAVASCRIPT CON VARIABILI TIPIZZATE, COME JAVA. 
		
	* JAVASCRIPT E' SINGLE THREAD: PUO' FARE SOLO UNA COSA ALLA VOLTA ! 
		COSA SUCCEDE PERO SE UN OPERAZIONE DURA MOLTO, PER ESEMPIO FETCH DI DATI DAL SERVER ? HO BISOGNO DI UN NON-BLOCKING BEHAVIOUR, LO SI OTTIENE COL EVENT LOOP: CIOE' FAR GIRARE LONG RUNNING TASK IN "BACKGROUND" E POI RIMETTERLI NEL MAIN THREAD QUANDO SONO TERMINATI, NON HO CAPITO !
		
	* JAVASCRIPT ENGINE 	E' UN PROGRAMMA CHE ESEGUE CODICE JAVASCRIPT, ESEMPIO: V8 DI GOOGLE CHROME, USATO ANCHE IN NODE.JS 
		E' COMPOSTO DA: 
		. CALL STACK 	E' DOVE VIENE ESEGUITO IL CODICE, USANDO L'EXECUTION CONTEXT, IN PARTICOLARE ESISTE UN SOLO "GLOBAL" EC, PER L'ESECUZIONE DEL TOP-LEVEL CODE, E TANTI EC QUANTI SONO LE FUNCTION E I METODI PRESENTI
			JAVASCRIPT ERA UN LINGUAGGIO INTERPRETATO MA ORA USA SIA COMPILAZIONE CHE INTERPRETE, E' JUST-IN-TIME (JIT) COMPILATION: L'INTERO CODICE VIENE COMPILATO IN CODICE MACCHINA E POI ESEGUITO IMMEDIATAMENTE, NON VIENE PRODOTTO UN FILE COMPILATO, IL CODICE COMPILATO VIENE ESEGUITO IMMEDIATAMENTE 
		. HEAP 			E' UN POOL DI MEMORIA NON STRUTTURATO CHE MEMORIZZA TUTTI GLI OGGETTI DI CUI HA BISOGNO DI CODICE IN ESECUZIONE 
			
	* JAVASCRIPT RUNTIME DEL BROWSER, E' COMPOSTO DA: 
		. JAVASCRIPT ENGINE 
		. WEB APIs (DOM, TIMERS, Fetch API, altro..) 
		. CALLBACK QUEUE (click, timer, data..): E' UNA STRUTTURA DATI CHE ACCOGLIE LE FUNCTION DI CALLBACK NEL MOMENTO IN CUI VENGONO EVOCATE
			UNA FUNZIONE DI CALLBACK ("RICHIAMO") E' UNA FUNCTION CHE VIENE INVOCATA PER ESEMPIO AL VERIFICARSI DI UN EVENTO.
			QUANDO L'EVENTO SI VERIFICA, PER ESEMPIO IL CLICK SU UN BUTTON, VIENE CHIAMATA LA RELATIVA FUNCTION DI CALLBACK, DICHIARATA IN button.addEventListener('click', function).
			QUESTA FUNCTION VIENE AGGIUNTA IN CODA ALLA CALLBACK QUEUE E QUANDO IL CALL STACK DELL'JS ENGINE E' VUOTO (NON STA ESEGUENDO NULLA) ALLORA LA FUNCTION VIENE PASSATA DALLA QUEUE AL CALL STACK E LI' VIENE ESEGUITA. 
		. EVENT LOOP 
			IL PROCESSO CHE SI OCCUPA DI PASSARE LE FUNCTION DALLA QUEUE ALLO CALL STACK QUANDO E' VUOTO SI CHIAMA *EVENT LOOP* 
			E' ESSENZIONALE PER IL NON-BLOCKING CONCURRENT MODEL 
			
	* JAVASCRIPT RUNTIME IN NODE.JS: 
		. JS ENGINE 
		. NON CI SONO LE WEB APIs, ESISTONO SOLO NEI BROWSER, MA ESISTONO C++ BINDINGS E THREAD POOL 
		. CALLBACK QUEUE 
		. EVENT LOOP 
					
	IN ESECUZIONE, DOPO CHE IL CODICE E' STATO APPENA COMPILATO, VIENE CREATO IL *GLOBAL EXECUTION CONTEXT* PER IL "TOP-LEVEL CODE" CIOE' IL CODICE JS CHE STA AL DI FUORI DELLE FUNCTION, E IN QUESTO CONTEXT VIENE ESEGUITO APPUNTO IL TOP-LEVEL CODE. IN UN JAVASCRIPT ENGINE ESISTE SOLO UN GLOBAL EXECUTION CONTEXT, E N ALTRI EXECUTION CONTEXT, UNA PER OGNI FUNCTION 
	UN *EXECUTION CONTEXT* E' UN ENVIRONMENT IN CUI VIENE ESEGUITO DEL CODICE JS, MEMORIZZA TUTTE LE INFO NECESSARIE PER LA SUA ESECUZIONE, COME VARIABILI, ARGOMENTI PASSATI ALLE FUNZIONI ECC..
		QUINDI IL CODICE JS VIENE ESEGUITO SEMPRE DENTRO UN EXECUTION CONTEXT. 
		VIENE CREATO UN SOLO GLOBAL EC, PER IL TOP-LEVEL CODE, E UN EC PER OGNI FUNCTION E METODO ESEGUITI, CON TUTTO QUELLO CHE SERVE PER LA LORO ESECUZIONE. L'INSIEME DI TUTTI GLI EC FORMA IL *CALL STACK*. 
		QUANDO TUTTO IL CODICE E' STATO ESEGUITO, L'ENGINE DI JS ATTENDERA' L'INVOCAZIONE DELLE FUNZIONI DI CALLBACK, PER ESEMPIO QUELLE ASSOCIATE AGLI EVENTI, CHE GLI VERRANNO FORNITE DAL EVENT LOOP, CHE LE ANDRA' A PRENDERE DAL CALLBACK QUEUE. 
		
	COSA C'E' DENTRO UN EXECUTION CONTEXT (RICORDIAMO NE ESISTE UNO PER OGNI FUNCTION ESEGUITA NEL CALL STACK): 
		. VARIABLE ENVIRONMENT: DICHIARAZIONI DI VAR, LET, CONST, FUNCTION, arguments OBJECT CHE CONTIENE GLI ARGOMENTI PASSATI ALLA FUNCTION 
		. SCOPE CHAIN: RIFERIMENTI ALLE VARIABILI AL DI FUORI DELLA FUNCTION 
		. OGGETTO this ! 
	TUTTO QUESTO VIENE CREATO IN UNA FASE APPENA PRIMA L'ESECUZIONE, CHE SI CHIAMA "CREATION PHASE". 
	*** NOTA BENE SUGLI ARROW FUNCTIONS: GLI EC DELLE ARROW FUNCTION NON HANNO I LORO SPECIFICI OGGETTI arguments E this MA USANO QUELLI DELLA LORO PIU' VICINA REGULAR FUNCTION PARENT, CIOE' LA FUNZIONE NORMALE (NON ARROW) DI LIVELLO SUPERIORE. (DA APPROFONDIRE)
	
	SCOPING: COME LE VARIABILI SONO ORGANIZZATE E ACCEDUTE. 
		JAVASCRIPT HA IL *LEXICAL SCOPING": LO SCOPING E' CONTROLLATO DALL'USO DI FUNZIONI E BLOCCHI DI CODICE ({...})
	SCOPE: SPAZIO O ENVIRONMENT IN CUI UNA CERTA VARIABILE E' DICHIARATA (VARIABLE ENVIRONMENT DEL CE IN CASO DI FUNCTION). 
		. GLOBAL SCOPE: PER VARIABILI DICHIARATE NEL TOP-LEVEL CODE, QUELLO AL DI FUORI DI TUTTE LE FUNCTIONS E METODI 
			LE VARIABILI DICHIARATE IN GLOBAL SCOPE SONO ACCESSIBILI *OVUNQUE*, INFATTI SI CHIAMANO *GLOBAL VARIABLES*
		. FUNCTION SCOPE: PER VARIABILI DICHIARATE ALL'INTERNO DI UNA FUNCTION, SONO ACCESSIBILI SONO ALL'INTERNO DELLA FUNCTION, NON AL DI FUORI. CHIAMATO ANCHE *LOCAL SCOPE*
		. BLOCK SCOPE (ES6): VARIABILI DICHIARATE CON let O const ALL'INTERNO DEL BLOCCO {  } SONO ACCESSIBILI SOLO DAL CODICE ALL'INTERNO DEL BLOCCO {  }. var INVECE E' ACCESSIBILE ANCHE DALL'ESTERNO DEL BLOCCO, IN PRATICA E' FUNCTION SCOPE ! ANCHE LE FUNCTION DICHIARATE IN UN BLOCCO CON CONST O LET SONO SCOPE BLOCK 
	SCOPE DI UNA VARIABLE: IL PEZZO DI CODICE IN CUI LA VARIABILE PUO' ESSERE ACCEDUTA (O DICHIARATA ?? NON E' CHIARO)
		ATTENZIONE: PER "VARIABILE" SI INTENDE ANCHE LE FUNCTION, CHE IN JAVASCRIPT SONO VALORI MEMORIZZATI IN VARIABILI !
	UNO SCOPE HA ACCESSO ALLE VARIABILI DEGLI SCOPE PIU' ESTERNI: IL MECCANISMO DI RICERCA PER CUI DA UNO SCOPE RISALGO AGLI SCOPE PARENT ALLA RICERCA DELLA DICHIARAZIONE DI UNA VARIABILE SI CHIAMA * VARIABLE LOOKUP IN SCOPE CHAIN*. IL LOOK "DOWN" OVVIAMENTE NON FUNZIONA. 
	** NOTA BENE
		1. SE DICHIARE CON CONST/LET UNA VARIABILE CHE E' GIA' STATA DICHIARATA IN UNO SCOPE PARENT, SI PUO' FARE, NESSUN ERRORE DI RUNTIME ! SONO VARIABILI IN SCOPE DIVERSI E ANCHE PROBABILMENTE IN EXECUTION CONTEXT DIVERSI. 
			VUOL DIRE CHE COL SCOPE CHAIN LA VARIABILE VIENE TROVATA PRIMA. 
			STESSA COSA PER GLI ARGOMENTI DELLE FUNCTION: POSSONO AVERE GLI STESSI NOMI IN PIU' FUNZIONI, NO PROBLEMA. 
		2. DI FATTO L'UNICA DIFFERENZA, CREDO, TRA USARE VAR O CONST/LET E' NEI BLOCCHI DI CODICE. NELLE FUNCTION E NEL TOP-LEVEL CODE NON C'E' NESSUNA DIFFERENZA: LO SCOPE CHAIN E' SEMPRE IN SALITA, MAI IN DISCESA. 
	
	HOISING: MECCANISMO NELL'EXECUTION CONTEXT/VARIABLE ENVIRONMENT PER CUI ALCUNI TIPI DI VARIABILI SONO ACCESSIBILI/USABILI NEL CODICE *PRIMA* CHE VENGANO DICHIARATE. 
		QUESTO SUCCEDE PERCHE' PRIMA DELL'ESECUZIONE DEL CODICE (DOPO CHE E' STATO COMPILATO!), NELLA FASE CHIAMATA *CREATION PHASE*, NEL CODICE VENGONO CERCATE TUTTE LE DICHIARAZIONI DI VARIABILI (COMPRESE LE FUNCTION OF COURSE), E PER OGNI VARIABILE VIENE CREATA UNA PROPERTY NEL *VARIABLE ENVIRONMENT OBJECT*, QUINDI DI FATTO L'ENGINE JS "CONOSCE" OGNI VARIABILE GIA' PRIMA DELL'ESECUZIONE DEL CODICE ! 
		L'HOISTING VARIA A SECONDA DEL TIPO DI VARIABILE: 
									HOISTED 		INITIAL VALUE 			SCOPE								NOTE 
		. FUNCTION DECLARATION 		YES				ACTUAL FUNCTION			BLOCK (solo con strict mode on)		VUOL DIRE CHE POSSO INVOCARE UNA FUNCTION PRIMA DELLA SUA DICHIARAZIONE 
		. VAR VARIABLES*			YES				undefined				FUNCTION							COMPORTAMENTO "WEIRD", MOTIVO PER CUI USARE LET/CONST INVECE CHE VAR
		. LET/CONST					NO				uninitialized, TDZ		BLOCK 								IN REALTA' SONO HOISTATE MA E' COME SE NON LO FOSSERO PERCHE' NON VENGONO INIZIALIZZATE
																												ERRORE ReferenceError: Cannot access 'provalet' before initialization
																												TDZ: TEMPORAL DEAD ZONE, CODICE TRA L'INIZIO DELLO SCOPE E LA DICHIARAZIONE DELLA VARIABILE
																												    E' STATO INTRODOTTO DA ES6 PER EVIDENZIARE USO DI VARIABILI PRIMA DELLA LORO DICHIARAZIONE, INFATTI CON VAR NON OTTENGO ERRORI MA LA VARIABILE E' UNDEFINED !
		. FUNCTION EXPRESSION E 	DIPENDE SE USO LET/CONST O VAR, STESSO COMPORTAMENTO VEDI SOPRA 			IN GENERALE NON SI POSSONO USARE PRIMA DELLA LORO DICHIARAZIONE
		  ARROW FUNCTION 	
		  
		* CONSIDERAZIONI E BEST PRACTICES: 
			. NON USARE VAR ! 
			. DICHIARARE LE VARIABILI ALL'INIZIO DELLO SCOPE 
			. DICHIARARE PRIMA, USARE POI, ANCHE LE FUNCTION ! ANCHE QUELLE DICHIARATE CON "function"
			. NOTA BENE: VAR CREA LA VARIABILE NELL'OGGETTO WINDOWS. LET E CONST NON LO FANNO !! 
			
	**** THIS OBJECT ****
		. VARIABILE SPECIALE CREATA PER OGNI EXECUTION CONTEXT (OGNI FUNCTION).
		. PRENDE IL VALORE DELL (PUNTA ALL..) OWNER DELLA FUNCTION IN CUI IL THIS VIENE USATO
			NOTA BENE: OWNER E' L'OGGETTO CHE INVOCA LA FUNCTION !
		. NON E' STATICA. DIPENDE DA COME LA FUNCTION VIENE INVOCATA E IL SUO VALORE E' ASSEGNATO SOLO QUANDO CIO' AVVIENE: 
			TOP-LINE CODE (SCOPE GLOBAL) THIS PUNTA ALL'OGGETTO WINDOW (CHE E' IL SUO ONWER)
			METHOD					THIS PUNTA ALL'OGGETTO DEL METHOD (CHE E' IL SUO OWNER) 
			SEMPLICE INVOCAZIONE 	IN STRICT MODE: THIS = UNDEFINED	(PERCHE' NON PUNTA A UN OWNER) 
									NON IN STRICT MODE: THIS PUNTA ALL'OGGETTO WINDOW
			ARROW FUNCTION 			NON HA IL "SUO" THIS MA THIS PUNTA AL PRIMO FUNCTION NORMALE (NON ARROW) CHE CONTIENE L'ARROW FUNCTION (SI DICE "LEXICAL THIS") 
			EVENT LISTENER			THIS PUNTA ALL'ELEMENTO DOM A CUI LA FUNCTION E' COLLEGATA (CHE E' IL SUO OWNER) 
			new, call, apply, bind  PIU' AVANTI NEL CORSO.. 
			
		. THIS NON PUNTA *MAI* ALLA FUNCTION IN CUI VIENE USATA, SE PUNTA, PUNTA A QUALCOS'ALTRO. INOLTRE NON PUNTA *MAI* ALLA VARIABLE ENVIRONMENT DELLA FUNCTION IN CUI VIENE USATA 
		. ATTENZIONE AGLI OGGETTI: LE PARENTESI { } PER DEFINIRLO NON SONO UN BLOCK, NON HANNO BLOCK SCOPE ! PER CUI UN OGGETTO DICHIARATO IN TOP-LINE CODE HA GLOBAL SCOPE. 
		. NON USARE ARROW FUNCTION COME METODI DI UN OGGETTO !
		. SE HO BISOGNO DI DICHIARARE UNA FUNCTION DENTRO UN METODO E VOGLIO CHE IL THIS PUNTI ALL'OGGETTO HO DUE SOLUZIONI: 
			. (PRE ES6): PRIMA DELLA FUNCTION DICHIARO UNA VARIABILE VALORIZZATA CON THIS, DI SOLITO CHIAMATA CON THAT O SELF 
				const that = this; 
				function ... 	
					that.property 
			. (ES6): DICHIARO LA FUNCTION CON UN'ARROW FUNCTION INVECE CHE COME FUNZIONE REGOLARE, IN QUESTO MODO IL THIS NELL'ARROW FUNCTION PUNTA AL PRIMO SCOPE PARENT E QUINDI AL METODO, CHE PUNTA ALL'OGGETTO 
			
	**** ARGUMENTS OBJECT ****
		. E' UN ARRAY CON L'ELENCO DI TUTTI I PARAMETRI PASSATI ALLA FUNCTION, ANCHE QUELLI PER CUI NON HO PREVISTO UN NOME NELL'ELENCO (...) 
		. NOTA BENE: ARROW FUNCTION NON HANNO QUESTO OGGETTO, COME IL THIS 
		
	**** PRIMITIVI VS OGGETTI, BY VALUE, BY REFERENCE 
		. I TIPI PRIMITIVI (String, number, null, undefined, BigInt, Boolean, Symbol) SONO MEMORIZZATI NEL CALL STACK !, NELL'EXECUTION CONTEXT IN CUI SONO STATI DICHIARATI
			PER OGNI VARIABILE VIENE SALVATO L'IDENTIFIER, L'ADDRESS E IL VALUE CHE SI TROVA NELL'INDIRIZZO DELL'ADDRESS.
			*** ATTENZIONE: L'IDENTIFIER E' ASSOCIATO ALL'ADDRESS, NON DIRETTAMENTE AL VALUE
			IL VALUE REFERENZIATO DA UN ADDRESS NON PUO' ESSERE MODIFICATO, E' IMMUTABLE ! 
			QUANDO DICHIARO CHE UNA VARIABILE E' UGUALE A UN ALTRA VARIABILE DI TIPO PRIMITIVE IN PRATICA ASSEGNO AL NUOVO IDENTIFIER LO STESSO ADDRESS DEL PRIMO. 
			QUANDO PERO' CAMBIO IL VALORE, SICCOME IL VALUE DELL'ADDRESS E' IMMUTABLE (PERCHE' ?), VIENE ALLOCATA DELL'ALTRA MEMORIA COL NUOVO VALORE, E QUINDI UN NUOVO ADDRESS 
		. I TIPI REFERENCE (object, function, Array, altro..) SONO MEMORIZZATI NELL'HEAP
			PER OGNI OGGETTO VIENE SALVATO NELL'HEAP L'ADDRESS E IL VALUE ALL'INDIRIZZO INDICATO DALL'ADDRESS 
			MENTRE NEL CALL STACK VIENE SALVATO L'IDENTIFIER, L'ADDRESS CHE PUNTA A UN INDIRIZZO DI MEMORIA CHE CONTIENE IL VALUE, CIOE' L'ADDRESS DELL'HEAP IN CUI C'E' L'INDIRIZZO DEL VALUE 
			GLI OBJECT SONO SALVATI NELL'HEAP PERCHE' POSSONO ESSERE TROPPO GRANDI PER STARCI NELL CALL STACK. 
			QUANDO DICHIARO UN NUOVO OGGETTO = UN ALTRO OGGETTO GIA' ESISTENTE, DI FATTO VIENE CREATO UN NUOVO IDENTIFIER CHE, NEL CALL STACK, PUNTA ALLO STESSO ADDRESS DEL PRIMO OGGETTO, CHE COME VALORE HA L'ADDRESS DELL'HEAP IN CUI SI TROVANO LE PROPRIETA' DEL PRIMO OGGETTO. 
			QUANDO MODIFICO UNA PROPERTY DEL SECONDO OGGETTO, VIENE MODIFICATO L'OGGETTO NELL HEAP, CHE NON E' IMMUTABLE A DIFFERENZA DEL CALL STACK, PER CUI VIENE CAMBIATO L'OGGETTO INIZIALE, PERCHE' E' SEMPRE QUELLO ! DAL PUNTO DI VISTA DEL CALL STACK LA MODIFICA ALLA PROPERTY DELL'OBJECT NON HA CAMBIATO NULLA, E' RIMASTO IMMUTABLE. 
			DI FATTO HO DUE IDENTIFIER CHE PUNTANO ALLO STESSO VALUE NEL CALL STACK, CHE E' L'INDIRIZZO DI MEMORIA DELL'HEAP IN CUI SI TROVANO I VALORI DELL'OGGETTO.  
			QUINDI SONO IMMUTABILI SOLO LE VARIABILI CON TYPE PRIMITIVI MENTRE GLI OBJECT (QUINDI ANCHE FUNCTION, ARRAY, ECC.. ) SONO MUTABLE. 
			E' IL MOTIVO PER CUI POSSO DICHIARE UN OGGETTO CON CONST (ANCHE UN ARRAY..) MA POSSO POI MODIFICARNE LE PROPERTY: QUANDO MODIFICO, MODIFICO L'HEAP, NON IL CALL STACK. 
			QUANDO INVECE PROVO AD ASSEGNARE UN NUOVO OGGETTO ALL'OGGETTO DEFINITO CON CONST RICEVO UN ERRORE, PERCHE' STO TENTANDO DI ASSEGNARE UN NUOVO HEAP ADDRESS AL RIFERIMENTO NELL'ADDRESS DEL CALL STACK, MA AVENDOLO DEFINITO CONST E' IMMUTABILE. PER POTERGLI ASSEGNARE UN NUOVO OGGETTO DEVO DEFINIRLO CON LET. 
			
			NOTA BENE: PER ESEGUIRE UNA COPIA DI UN OGGETTO USARE LA FUNZIONE Object.assign CHE CONCATENA IL PRIMO OGGETTO COL SECONDO E RESTITUISCE UN OGGETTO RISULTANTE, IL TRUCCO E' PASSARE UN OGGETTO VUOTO E POI L'OGGETTO DA COPIARE: 
				const nuovo oggetto = Object.assign({empty-objecty},oggetto-da-copiare) 
				
				NOTA BENE: QUESTA COPIA PERO' ESEGUE SOLO COPIA DI PRIMO LIVELLO (SHALLOW COPY), CIOE' NON CREA COPIE DI EVENTUALI OGGETTI NELL'OGGETTO E COSI' VIA. 
				PER FARE QUESTA COPIA COMPLETA (DEEP CLONE) NON C'E' UN ISTRUZIONE SEMPLICE, MA SI USA UN TOOL ESTERNO (DA COMPLETARE)  
	 
	**** ALTRE ISTRUZIONI PER ARRAY ****		
		** DESTRUCTURING ARRAYS (ES6 FEATURE) : RIDURRE IL CONTENUTO DI ARRAY O OBJECT IN VARIABILI PIU' SEMPLICI, IN ALTRO MODO, CERCARE ELEMENTI SPECIFICI IN UN ARRAY E SALVARLI IN APPOSITE VARIABILI 
			const array = [1,2,3];		// LA PRESENZA DELLE PARENTESI QUADRE A SX DELL'= FA CAPIRE A JS CHE VOGLIO IL DESTRUCTURING DELL'ARRAY A DX 
			const [a,b,c] = array;		// ESTRAGGO TUTTI E TRE GLI ELEMENTI DELL'ARRAY IN TRE VARIABILI
			const [a,,b] = array;       // PER SALTARE ELEMENTI LASCIARE VUOTO TRA VIRGOLE, QUI SALTO IL SECONDO ELEMENTO DELL'ARRAY
			const [a,b] = array;		// PER PRENDERE SOLO I PRIMI N
				const array = [1,2,[3,4]];  // PRENDERE ARRAY DI ARRAY 
				const [a,b,[c,d]] = array 	
			const [a=1, b=1, c=1, d=1] = array; //IMPOSTARE VALORI DI DEFAULT PER ELEMENTI NON PRESENTI IN ARRAY IN INPUT, NELL'ESEMPIO IL QUARTO ELEMENTO DELL'ARRAY NON C'E' PER CUI D = 1
			
		** DESTRUCTURING OBJECTS (ES6): STESSA COSA DEGLI ARRAY MA COL VANTAGGIO CHE NON DEVO RISPETTARE L'ORDINE DELLE PROPERTIES. 
				QUANDO DICHIARO USO PARENTESI GRAFFE INVECE CHE QUADRE
				PER LE VARIABILI DEVO USARE GLI STESSI NOMI DELLE PROPERTY 
				NON DEVO RISPETTARE L'ORDINE DI DICHIARAZIONE DELLE PROPERTY NEGLI OGGETTI ! NON E' POSIZIONALE !
			const mioObj = {
			  propA: "ciao",
			  propB: "da",
			  propC: "giggi"
			}
			const { propA, propB, propC } = mioObj;
			const { propC, propA, propB } = mioObj;  // STESSA COSA ! NON E' POSIZIONALE !
			console.log(propA, propB, propC);
				
				SE VOGLIO USARE NOMI DIVERSI DALLE VARIABILI: 
			const { propA: property1, propB: property2, propC: property3 } = mioObj;
			console.log(property3, property2, property1);
				
				IMPOSTARE VALORI DI DEFAULT ALLE PROPERTY DEGLI OGGETTI, POSSO ANCHE CAMBIARE NOME NELLO STESSO MOMENTO !
			const {
			  propA: property1,
			  propB: property2,
			  propertyZZ: giggi = 'forza milan',	// propertyZZ non esiste nell'oggetto mioObj per cui gli assegno il valore 'forza milan' e gli cambio anche il nome in giggi (non ha molto senso..) 
			} = mioObj;
				
				SE VOGLIO MUTARE DELLE VARIABILI PRECEDENTEMENTE DICHIARATE CON LE VARIABILI DESTRUTTURATE DEVO RACCHIUDERE CON PARENTESI TONDA: 
			let a = 111;
			let b = 222;
			const obj = { a: 20, b: 30, c: 40 };
			({ a, b } = obj);		// RIASSEGNO A E B CON I NUOVI VALORI PRESI DALL'OGGETTO DESTRUTTURATO, DEVO USARE LE PARENTESI TONDE ALTRIMENTI OTTENGO ERRORE "Unexpected token.." 
			console.log(a, b);			
				
				SE DEVO DESTRUTTURARE UN OGGETTO CONTENUTO DENTRO UN ALTRO OGGETTO: 
			const mioObj = {
			  mioSubObj: {
				prop1: 10,
				prop2: 20,
			  },
			};
			const { mioSubObj: { prop1, prop2 } } = mioObj;		// DESTRUTTURO L'OGGETTO mioSubObj DENTRO DESTRUCTURING DI mioObj CHE LO CONTIENE 
			console.log(prop1, prop2);
				
				OGGETTI PASSATI A METODI O FUNCTION COME ARGOMENTI E COME DESTRUTTURARLI, POSSO IMPOSTARE VALORI DI DEFAULT, CAMBIARE NOME ECC.. 
			function provaDestr({
			  attr1: a = 'FORZA',
			  attr2: b = 'MILAN',
			  attr3: { uno, due } = { uno: 'DAJE', due: 'MEJO' },			// SE NON VIENE PASSATO attr3 IMPOSTO PER VALORE DI DEFAULT UN OGGETTO CON I DUE ATTRIBUTI VALORIZZATI
			  attr4 = '!!!',
			}) {
			  console.log(a, b, uno + 'gggg' + due, attr4);
			}
			provaDestr({
			  attr1: 'ciao',
			  attr2: 'da',
			  attr3: {
				uno: 'gig',
				due: 'gi',
			  },
			});
			provaDestr({
			  attr4: 'EJA EJA !!!',
			});
		
		** SPREAD OPERATOR (... A DX =) E' UN SIMBOLO (I TRE PUNTINI) CHE RAPPRESENTA TUTTI GLI ELEMENTI DI UN ARRAY, SENZA BISOGNO DI ELENCARLI 
			I TRE PUNTINI SONO SPREAD QUANDO SONO A DESTRA DELL' = 
				SE SONO A SINISTRA ALLORA E' REST PATTERN (VEDI CAPITOLO SEGUENTE)
			E' COME FARE DESTRUCTURING DI UN ARRAY, NEL SENSO CHE "ESTRAE", ESPANDE, TUTTI GLI ELEMENTI DI UN ARRAY, MA SENZA LA POSSIBILITA' DI VALORIZZARE ALTRETTANTE VARIABILI. 
			FUNZIONA NON SOLO PER GLI ARRAY MA IN GENERALE PER TUTTI GLI ITERABLES JAVASCRIPT (arrays, strings, maps, sets, MA NON OBJECT !)
			FUNZIONA ANCHE SUGLI ARGOMENTI DI FUNZIONI: SCOMPONE UN ARRAY PASSATO COME ARGOMENTI IN SINGOLI ELEMENTI 
			NOTA BENE: LO SPREAD SI PUO' USARE SOLO PER CONVERTIRE ITERABLES E SUGLI ARGOMENTI DI UNA FUNCTION !
			NOTA BENE2: DA ES 2018 SPREAD SI PUO' USARE ANCHE CON OBJECT, ANCHE SE NON SONO ITERABLES !!
			
			const mioarray = [5, 6, 7];
			const nuovoArray = [1, 2, 3, ...mioarray]; // AGGIUNGO TUTTI GLI ELEMENTI DI mioarray			
				
				AGGIUNGO UN NUOVO ELEMENTO ALLA FINE DI UN ARRAY ESISTENTE 			
			const newArray = [...nuovoArray, 8, 9, 10];
			
				USO SPREAD PER COPIARE UN ARRAY IN UN ALTRO, E' COME FARE Object.assign. (SHALLOW COPY, SOLO UN "LIVELLO")
			const newArray2 = [...newArray]; 
			
				CONCATENO DUE ARRAY 
			const newArray3 = [...newArray, ...newArray2]; //concateno due array
			
				ESEGUO SPREAD SU UNA STRINGA TRASFORMANDOLA IN ARRAY DI CARATTERI
			const stringa = "Ciao";
			const arrayStr = [...stringa];
			const arrayStr2 = [..."Ciao"]; 	// ANCHE COSI' 
			
				ESEGUO SPREAD SU UN ARGOMENTO DI UNA FUNCTION 
			console.log(...stringa);
			
				ESEGUO SPREAD PER CREARE UN NUOVO OGGETTO DA UN ALTRO E AGGIUNGERGI NUOVE PROPERTY 
			const obj1 = {
			  prop1: 'ciao',
			  prop2: 'da',
			  prop3: 'giggi',
			};

			const obj2 = { ...obj1, prop4: '!!!!' };				
			
				ESEGUO SPREAD PER FARE COPIA DI UN OGGETTO IN UN ALTRO (SHALLOW COPY, SOLO UN "LIVELLO") !
				
			const obj3 = { ...obj2 };
			
		** REST PATTERN (... A SX =)
			COME SPREAD, STESSI TRE PUNTINI MA SI USA A SINISTRA DELL = E HA EFFETTO CONTRARIO: UNISCE VARIABILI IN ARRAY. 
			FUNZIONA ANCHE CON GLI OGGETTI !
			FUNZIONA ANCHE NELLA DICHIARAZIONE DEGLI ARGOMENTI DI UNA FUNCTION: SIGNIFICA CHE ELEMENTI SINGOLI PASSATI AD UNA FUNCTION, NON IMPORTA QUANTI, VENGONO RAGGRUPPATI IN UN ARRAY 
			NOTA BENE: REST DEVE ESSERE L'ULTIMO ELEMENTO DEL DESTRUCTURING ALTRIMENTI ERRORE !
					   CI PUO' ESSERE UN SOLO REST IN UN DESTRUCTURING 
						
			const [a, b, ...altro] = [1, 2, 3, 4, 5];	// destructuring in cui a = 1, b = 2 e 3, 4, 5 vengono assegnati all'array altro 
			
			const arrayA = ['a', 'b', 'c'];
			const arrayB = ['d', 'e', 'f'];
			const [aa, , cc, ...resto] = [...arrayA, ...arrayB];    //combino spread, per unire i due array, e rest, per mettere d, e, f nell'array resto
			
			ESEMPIO CON OGGETTI: 
			let testjson = {	
			  "E": ["971"],
			  "C": ["443"],
			  "F": ["831", "719", "970"],
			  "G": ["111", "222"]
			};		
			const { G, ...objresto } = testjson;    // estraggo E dall'oggetto testjson e tutti gli altri oggetti li metto in objresto			
			
			ESEMPIO USO IN FUNCTION 			
			const add = function (...numbers) {		// dichiaro function che riceve N elementi e li impacca nell'array numbers 
			  console.log(numbers);
			}
			add(1, 2, 3, 4, 5);
			
			const x = [1, 2, 3];				
			add(...x);	// chiamo function add passando gli elementi dell'array x che ottengo facendo lo spread, e quando li riceve la function vengono nuovamente impaccati in array col rest 
			
			const testRest = function (primo, ...altri) {	// dichiaro function che accetta un parametro in primo e tutti gli altri nell'array altri
			  console.log(primo);
			  console.log(altri);
			}
			testRest(1, 2, 3, 4, 5);	// 1 viene assegnato a primo mentre 2,3,4,5 all'array altri 
			
		** SHORT CICUITING: && E || OPERATORS (AND E OR) 
			IN GENERALE GLI OPERATORI BOOLEAN SI POSSONO USARE ANCHE CON VALORI NON BOOLEAN E RESTITUISCONO VALORI NON BOOLEAN 
			|| (OR) : RESTITUISCE IL PRIMO VALORE TRULY DELL'ELENCO DI VALORI SEPARATO DA || 
			console.log(undefined || "Ciao")	RESTITUISCE CIAO PERCHE' IL PRIMO VALORE E' FALSY 
			console.log(undefined || 0 || '' || "Ciao" || 23)	RESTITUISCE CIAO PERCHE I PRIMI TRE SONO FALSY 
			
			VIENE UTILE PER RIMPIAZZARE IL TERNARY OPERATOR ( ? .. : ) 
			INVECE DI FARE COSI'
				const pippo = pluto ? pluto : "no pluto"; 	// se pluto non e' falsy uso pluto altrimento imposto "no pluto"
			FACCIO COSI'
				const pippo = pluto || "no pluto"		// restituisce il primo valore truly, quindi se pluto e' falsy restituisce "no pluto"
				
			
			