
	let indice = ..;
	while(condizione) {			//continua a ripetere fintanto che la condizione è vera
		istruzioni
		istruzioni
		incremento indice
	}
	
	** ROBA UTILE DA INSTALLARE IN VS CODE 
		PRETTIER 
			poi andare in setting, cercare default formatter, selezionare esbenp.prettier-vscode
				selezionare anche format on save, mettere la spunta su Editor: Format On Save
		SNIPPET, PER EVITARE DI SCRIVERE console.log O ALTRA ROBA RIPETITIVA 
			setting, use snippet, use new global snippet file, dare nome del cavolo, uncomment l'esempio print to console 
			
		LIVE SERVER : PER AUTOMATIZZARE RELOAD BROWSER DOPO MODIFICA A JS 
			aggiunge pulsante GoLive in basso a destra
			per lanciarlo: aprire terminale e nel folder del progetto digitare live-server
			
	** codewars.com challenges for free 
	
	********* CSS **********
	
	inline elements: occupano spazio in una riga, non box, tipo tag anchor, input, button
	block elements : il loro spazio un box che occupa tutta la larghezza dello schermo
	
	commenti: /* .... */
	
	Global Reset: reimpostare tutti i margin e i padding 
		Per selezionare tutti gli elementi usare il selettore * 
	
	* {
		margin: 0;		// quando si imposta zero non serve specificare px o %
		padding: 0;
		box-sizing: border-box; //serve per dichiarare che voglio le dimensioni di un elemento esattamente come le ho dichiarate: se dichiaro una form con width 400 e padding 25 e margin 5, il width non sarà 400+25+25+5 ma la somma di tutto dovrà fare 400 
	}
	
	elemento1, elemento2 {  //stile per più elementi
		...
		...
	}
	
	** child selector: per selezionare un elemento contenuto in un altro elemento scrivo l'elemento che contiene e poi l'elemento contenuto separati da spazio 
	#mio-div h2 {		// seleziono elemento h2 contenuto nell'elemento con id mio-div
	
	}
	
	********** JAVASCRIPT DOM MANIPULATION ***********
	
	document.querySelector('selettore') // esempio .classe #div ecc..
		NOTA se selettore seleziona più elementi, restituisce solo il primo. per avere l'array di tutti gli elementi usare querySelectorAll
		non seleziona come jquery, seleziona proprio l'html dell'elemento selezionato 
		.textContent 	restituisce testo dell'elemento selezionato, per esempio per gli elementi p
		.value			restituisce valore di un elemento, per esempio input text 
	
	document.querySelectorAll('selettore') // esempio .classe #div ecc..  seleziona TUTTI gli elementi selezionati dal selettore in input 
		
	DOM = Document Object Manipulation, il browser crea una rappresentazione ad albero di tutti gli elementi dell'html 
		essendo un albero sono validi tutti i concetti tipici: child element, parent element, sibling element (fratello) ecc.. 
		per esempio un elemento P contenente un testo e un anchor, sarà un elemento con due child: text e a, il primo valorizzato col testo, il secondo con un child text per il suo testo 
		document è l'oggetto entry point del DOM 
		DOM non fa parte di Javascript ma fa parte del WEB APIs, implementate in ciascun browser e con le quali Javascript si interfaccia 
		
	Event Listener = codice eseguito al verificarsi di un evento ad uno specifico elemento 
		selezionare elemento, per esempio un button, e poi addEventListener 
		document.querySelector('.check').addEventListener(evento, funzione);
		
		document.querySelector('body').style.backgroundColor = '#60b347' 		// seleziono body element e imposto css style background-color che in javascript si scrive in Camel Case quindi backgroundColor  
																				// gli style si impostano sempre con una stringa ! no numeri
																				
		document.getElementById('id')	// get per id, non serve cancelletto !
																				
	elementoselezionato.classList	// restituisce elenco di classi dell'elemento 
		classList.remove('hidden','','') // rimuovo uno o più classi dall'elemento, non mettere il punto davanti !
		classList.add 
		classList.contains('hidden')     // 
		classList.toggle('class')   	 // se c'è il class lo toglie, altrimenti lo aggiunge 
		
	elementoselezionato.src = url 	// imposto l'attributo src a un elemento che lo supporta come img 
		
	Global events: sono quelli della tastiera, legati al document, quindi l'addEventListener in questo caso lo si fa su document 
		tre eventi intercettabili: 
			keyup		
			keypress
			keydown
		document.addEventListener('keydown', function(e){
			// nell'oggetto e che riceviamo in input ci sono tutte le info sull'evento catturato
			
		});
		
		
		
	*********** COME FUNZIONA JAVASCRIPT  ***************
	
	* MULTI-PARADIGM: 
		. PROCEDURAL PROGRAMMING 
		. OBJECT-ORIENTED PROGRAMMING
		. FUNCTIONAL PROGRAMMING
	  E: 
		. IMPERATIVE 
		. DECLARATIVE 
	
	* PROTOTYPE: E' LA CLASSE !! CREO IL PROTOTYPE CON TUTTI I METODI E POI QUANDO LO USO, L'OGGETTO CREATO EREDITA TUTTI I METODI 
	
	* FIRST-CLASS FUNCTIONS: QUANDO LE FUNCTIONS SONO GESTITE COME VARIABILI, POSSO PASSARE UNA FUNCTION COME PARAMETRO AD UN'ALTRA FUNCTION E UNA FUNCTION PUO' RESTITUIRE COME RISULTATO UNA FUNCTION 
	
	* DYNAMIC: LE VARIABILI NON SONO TIPIZZATE, LO SONO I VALORI ASSEGNATI ALLE VARIABILI. QUANDO ASSEGNO VALORI DIVERSI AD UNA VARIABILE, IL DATA TYPE DELLA VARIABILE VIENE CAMBIATO AUTOMATICAMENTE
		ESISTE TYPESCRIPT: UNA VERSIONE DI JAVASCRIPT CON VARIABILI TIPIZZATE, COME JAVA. 
		
	* JAVASCRIPT E' SINGLE THREAD: PUO' FARE SOLO UNA COSA ALLA VOLTA ! 
		COSA SUCCEDE PERO SE UN OPERAZIONE DURA MOLTO, PER ESEMPIO FETCH DI DATI DAL SERVER ? HO BISOGNO DI UN NON-BLOCKING BEHAVIOUR, LO SI OTTIENE COL EVENT LOOP: CIOE' FAR GIRARE LONG RUNNING TASK IN "BACKGROUND" E POI RIMETTERLI NEL MAIN THREAD QUANDO SONO TERMINATI, NON HO CAPITO !
		
	* JAVASCRIPT ENGINE 	E' UN PROGRAMMA CHE ESEGUE CODICE JAVASCRIPT, ESEMPIO: V8 DI GOOGLE CHROME, USATO ANCHE IN NODE.JS 
		E' COMPOSTO DA: 
		. CALL STACK 	E' DOVE VIENE ESEGUITO IL CODICE, USANDO L'EXECUTION CONTEXT, IN PARTICOLARE ESISTE UN SOLO "GLOBAL" EC, PER L'ESECUZIONE DEL TOP-LEVEL CODE, E TANTI EC QUANTI SONO LE FUNCTION E I METODI PRESENTI
			JAVASCRIPT ERA UN LINGUAGGIO INTERPRETATO MA ORA USA SIA COMPILAZIONE CHE INTERPRETE, E' JUST-IN-TIME (JIT) COMPILATION: L'INTERO CODICE VIENE COMPILATO IN CODICE MACCHINA E POI ESEGUITO IMMEDIATAMENTE, NON VIENE PRODOTTO UN FILE COMPILATO, IL CODICE COMPILATO VIENE ESEGUITO IMMEDIATAMENTE 
		. HEAP 			E' UN POOL DI MEMORIA NON STRUTTURATO CHE MEMORIZZA TUTTI GLI OGGETTI DI CUI HA BISOGNO DI CODICE IN ESECUZIONE 
			
	* JAVASCRIPT RUNTIME DEL BROWSER, E' COMPOSTO DA: 
		. JAVASCRIPT ENGINE 
		. WEB APIs (DOM, TIMERS, Fetch API, altro..) 
		. CALLBACK QUEUE (click, timer, data..): E' UNA STRUTTURA DATI CHE ACCOGLIE LE FUNCTION DI CALLBACK NEL MOMENTO IN CUI VENGONO EVOCATE
			UNA FUNZIONE DI CALLBACK ("RICHIAMO") E' UNA FUNCTION CHE VIENE INVOCATA PER ESEMPIO AL VERIFICARSI DI UN EVENTO.
			QUANDO L'EVENTO SI VERIFICA, PER ESEMPIO IL CLICK SU UN BUTTON, VIENE CHIAMATA LA RELATIVA FUNCTION DI CALLBACK, DICHIARATA IN button.addEventListener('click', function).
			QUESTA FUNCTION VIENE AGGIUNTA IN CODA ALLA CALLBACK QUEUE E QUANDO IL CALL STACK DELL'JS ENGINE E' VUOTO (NON STA ESEGUENDO NULLA) ALLORA LA FUNCTION VIENE PASSATA DALLA QUEUE AL CALL STACK E LI' VIENE ESEGUITA. 
		. EVENT LOOP 
			IL PROCESSO CHE SI OCCUPA DI PASSARE LE FUNCTION DALLA QUEUE ALLO CALL STACK QUANDO E' VUOTO SI CHIAMA *EVENT LOOP* 
			E' ESSENZIONALE PER IL NON-BLOCKING CONCURRENT MODEL 
			
	* JAVASCRIPT RUNTIME IN NODE.JS: 
		. JS ENGINE 
		. NON CI SONO LE WEB APIs, ESISTONO SOLO NEI BROWSER, MA ESISTONO C++ BINDINGS E THREAD POOL 
		. CALLBACK QUEUE 
		. EVENT LOOP 
					
	IN ESECUZIONE, DOPO CHE IL CODICE E' STATO APPENA COMPILATO, VIENE CREATO IL *GLOBAL EXECUTION CONTEXT* PER IL "TOP-LEVEL CODE" CIOE' IL CODICE JS CHE STA AL DI FUORI DELLE FUNCTION, E IN QUESTO CONTEXT VIENE ESEGUITO APPUNTO IL TOP-LEVEL CODE. IN UN JAVASCRIPT ENGINE ESISTE SOLO UN GLOBAL EXECUTION CONTEXT, E N ALTRI EXECUTION CONTEXT, UNA PER OGNI FUNCTION 
	UN *EXECUTION CONTEXT* E' UN ENVIRONMENT IN CUI VIENE ESEGUITO DEL CODICE JS, MEMORIZZA TUTTE LE INFO NECESSARIE PER LA SUA ESECUZIONE, COME VARIABILI, ARGOMENTI PASSATI ALLE FUNZIONI ECC..
		QUINDI IL CODICE JS VIENE ESEGUITO SEMPRE DENTRO UN EXECUTION CONTEXT. 
		VIENE CREATO UN SOLO GLOBAL EC, PER IL TOP-LEVEL CODE, E UN EC PER OGNI FUNCTION E METODO ESEGUITI, CON TUTTO QUELLO CHE SERVE PER LA LORO ESECUZIONE. L'INSIEME DI TUTTI GLI EC FORMA IL *CALL STACK*. 
		QUANDO TUTTO IL CODICE E' STATO ESEGUITO, L'ENGINE DI JS ATTENDERA' L'INVOCAZIONE DELLE FUNZIONI DI CALLBACK, PER ESEMPIO QUELLE ASSOCIATE AGLI EVENTI, CHE GLI VERRANNO FORNITE DAL EVENT LOOP, CHE LE ANDRA' A PRENDERE DAL CALLBACK QUEUE. 
		
	COSA C'E' DENTRO UN EXECUTION CONTEXT (RICORDIAMO NE ESISTE UNO PER OGNI FUNCTION ESEGUITA NEL CALL STACK): 
		. VARIABLE ENVIRONMENT: DICHIARAZIONI DI VAR, LET, CONST, FUNCTION, arguments OBJECT CHE CONTIENE GLI ARGOMENTI PASSATI ALLA FUNCTION 
		. SCOPE CHAIN: RIFERIMENTI ALLE VARIABILI AL DI FUORI DELLA FUNCTION 
		. OGGETTO this ! 
	TUTTO QUESTO VIENE CREATO IN UNA FASE APPENA PRIMA L'ESECUZIONE, CHE SI CHIAMA "CREATION PHASE". 
	*** NOTA BENE SUGLI ARROW FUNCTIONS: GLI EC DELLE ARROW FUNCTION NON HANNO I LORO SPECIFICI OGGETTI arguments E this MA USANO QUELLI DELLA LORO PIU' VICINA REGULAR FUNCTION PARENT, CIOE' LA FUNZIONE NORMALE (NON ARROW) DI LIVELLO SUPERIORE. (DA APPROFONDIRE)
	
	SCOPING: COME LE VARIABILI SONO ORGANIZZATE E ACCEDUTE. 
		JAVASCRIPT HA IL *LEXICAL SCOPING": LO SCOPING E' CONTROLLATO DALL'USO DI FUNZIONI E BLOCCHI DI CODICE ({...})
	SCOPE: SPAZIO O ENVIRONMENT IN CUI UNA CERTA VARIABILE E' DICHIARATA (VARIABLE ENVIRONMENT DEL CE IN CASO DI FUNCTION). 
		. GLOBAL SCOPE: PER VARIABILI DICHIARATE NEL TOP-LEVEL CODE, QUELLO AL DI FUORI DI TUTTE LE FUNCTIONS E METODI 
			LE VARIABILI DICHIARATE IN GLOBAL SCOPE SONO ACCESSIBILI *OVUNQUE*, INFATTI SI CHIAMANO *GLOBAL VARIABLES*
		. FUNCTION SCOPE: PER VARIABILI DICHIARATE ALL'INTERNO DI UNA FUNCTION, SONO ACCESSIBILI SONO ALL'INTERNO DELLA FUNCTION, NON AL DI FUORI. CHIAMATO ANCHE *LOCAL SCOPE*
		. BLOCK SCOPE (ES6): VARIABILI DICHIARATE CON let O const ALL'INTERNO DEL BLOCCO {  } SONO ACCESSIBILI SOLO DAL CODICE ALL'INTERNO DEL BLOCCO {  }. var INVECE E' ACCESSIBILE ANCHE DALL'ESTERNO DEL BLOCCO, IN PRATICA E' FUNCTION SCOPE ! ANCHE LE FUNCTION DICHIARATE IN UN BLOCCO CON CONST O LET SONO SCOPE BLOCK 
	SCOPE DI UNA VARIABLE: IL PEZZO DI CODICE IN CUI LA VARIABILE PUO' ESSERE ACCEDUTA (O DICHIARATA ?? NON E' CHIARO)
		ATTENZIONE: PER "VARIABILE" SI INTENDE ANCHE LE FUNCTION, CHE IN JAVASCRIPT SONO VALORI MEMORIZZATI IN VARIABILI !
	UNO SCOPE HA ACCESSO ALLE VARIABILI DEGLI SCOPE PIU' ESTERNI: IL MECCANISMO DI RICERCA PER CUI DA UNO SCOPE RISALGO AGLI SCOPE PARENT ALLA RICERCA DELLA DICHIARAZIONE DI UNA VARIABILE SI CHIAMA * VARIABLE LOOKUP IN SCOPE CHAIN*. IL LOOK "DOWN" OVVIAMENTE NON FUNZIONA. 
	** NOTA BENE
		1. SE DICHIARE CON CONST/LET UNA VARIABILE CHE E' GIA' STATA DICHIARATA IN UNO SCOPE PARENT, SI PUO' FARE, NESSUN ERRORE DI RUNTIME ! SONO VARIABILI IN SCOPE DIVERSI E ANCHE PROBABILMENTE IN EXECUTION CONTEXT DIVERSI. 
			VUOL DIRE CHE COL SCOPE CHAIN LA VARIABILE VIENE TROVATA PRIMA. 
			STESSA COSA PER GLI ARGOMENTI DELLE FUNCTION: POSSONO AVERE GLI STESSI NOMI IN PIU' FUNZIONI, NO PROBLEMA. 
		2. DI FATTO L'UNICA DIFFERENZA, CREDO, TRA USARE VAR O CONST/LET E' NEI BLOCCHI DI CODICE. NELLE FUNCTION E NEL TOP-LEVEL CODE NON C'E' NESSUNA DIFFERENZA: LO SCOPE CHAIN E' SEMPRE IN SALITA, MAI IN DISCESA. 
	
	
	*** VERIFICARE 
		perché si può mettere const un array ?????
		
		